"""
Spline based formulation for water thermodynamic properties (density, temperature, viscosity) with respect to pressure
and enthalpy. The code does support pressure and temperature inputs, in that case the temperature is converted to
enthalpy using IAPWS thermodynamic formulation.

Copyright (c) 2019 Martin LETOURNEUR

Permission is hereby granted, free of charge, to any person obtaining a copy
of this software and associated documentation files (the "Software"), to deal
in the Software without restriction, including without limitation the rights
to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
copies of the Software, and to permit persons to whom the Software is
furnished to do so, subject to the following conditions:

The above copyright notice and this permission notice shall be included in all
copies or substantial portions of the Software.

THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
SOFTWARE.
"""

# ----------------------------------------------------------------------------------------------------------------------
# IMPORTS
import numpy
from math import acos, log, exp
import json
import matplotlib.pyplot as plt
from scipy.interpolate.fitpack2 import fitpack, dfitpack
# ---------------------------------------------------------------------------------------------------------------------
# CONSTANT VARIABLES

# THERMODYNAMIC CONSTANTS
PSTAR1 = 16.53e6 #p normali_sation for region 1
PSTAR2 = 1.0e6 #p normali_sation for region 2
PSTAR5 = 1.0e6 #normali_sation for region 5
PSTAR4 = 1.0e6 #normali_sation for region 4
IPSTAR = 1.0e-6 #p normali_sation for inverse function in region 2

HSTAR1 = 2.5e6 #h normali_sation for region 1
IHSTAR = 5.0e-7 #h normali_sation for inverse function in region 2

TSTAR1 = 1386.0 #T normali_sation for region 1
TSTAR2 = 540.0 #T normali_sation for region 2
TSTAR5 = 1000. #T normali_sation for region 5

RH2O = 461.526 #Specific gas constant of water vapour

PCRIT = 22064000.0 #critical pressure
TCRIT = 647.096 #critical temperature
DCRIT = 322.0 #critical density
HCRIT = 2087546.845 #critical enthalpy

PLIMIT1 = 100.0e6
PLIMIT4A = 16.5292e6 #P limit between regions 1 and 2, important for 2 phase
PLIMIT5 = 10.0e6

TLIMIT1 = 623.15 #T limit between region 1 and 3
TLIMIT2 = 1073.15 #T limit between region 2 and 5

ptriple = 611.657 #pressure at triple point

PMIN = 611.657
PMAX = 1e8

HMIN = 1e3
HMAX = 4.5e6

nr4 = numpy.array([
    0.11670521452767e4, -0.72421316703206e6, -0.17073846940092e2,
    0.12020824702470e5, -0.32325550322333e7, 0.14915108613530e2,
    -0.48232657361591e4, 0.40511340542057e6, -0.23855557567849,
    0.65017534844798e3])

nr23 = numpy.array([
    0.34805185628969e3, -0.11671859879975e1, 0.10192970039326e-2,
    0.57254459862746e3, 0.13918839778870e2])

# Constants used for dinamic viscosity computation in the 2-phase region
mustar = 1.00e-6

h0v = numpy.array([1.67752, 2.20462, 0.6366564, -0.241605])

h1v = numpy.array([
    5.20094e-1, 8.50895e-2, -1.08374, -2.89555e-1, 2.22531e-1,
    9.99115e-1, 1.88797, 1.26613, 1.20573e-1, -2.81378e-1,
    -9.06851e-1, -7.72479e-1, -4.89837e-1, -2.57040e-1, 1.61913e-1,
    2.57399e-1, -3.25372e-2, 6.98452e-2, 8.72102e-3, -4.35673e-3,
    -5.93264e-4])

ivs = numpy.array([0, 1, 2, 3, 0, 1, 2, 3, 5, 0, 1, 2, 3, 4, 0, 1, 0, 3, 4, 3, 5])
jvs = numpy.array([0, 0, 0, 0, 1, 1, 1, 1, 1, 2, 2, 2, 2, 2, 3, 3, 4, 4, 5, 6, 6])

ticv = ((2, (1, 1)), (3, (2, 1)))
tscv = ((2, (1, 1)), (3, (2, 1)), (4, (2, 2)), (5, (3, 2)))
dscv = ((2, (1, 1)), (3, (2, 1)), (4, (2, 2)), (5, (3, 2)), (6, (3, 3)))

# ITERATION AND EPSILON
delt = 1e-5
eps = 1e-18
IMAX = 100
# SPLINES DATA
spl_objs = {"v": {"c": [-1.2739819025214405, 0.14113099735259027, -0.05049009274817706, 0.03608611899110503, 0.04001586813957625, 0.014577668481866701, 0.02735920478987571, 0.01885829988102059, 0.02236070615672773, 0.02064933716446989, 0.02727840681363259, 0.019427969038155773, 0.03374141963173628, 0.3132942999538795, -0.04709669911432002, 0.00032439736716582956, -0.021008192677257398, -0.021749620150363747, -0.015954560165686082, -0.01807473209397442, -0.01645974152493848, -0.01706775347612771, -0.01664261748726936, -0.017286544325713346, -0.01640876496622313, -0.017872882385403903, -0.1570778051677575, 0.0379587503465757, 0.011897711604902383, 0.022095751419694665, 0.02169683807073497, 0.01823492663819959, 0.01817638165937141, 0.01649816235944454, 0.015909908486279795, 0.014971160168248603, 0.0143029218696742, 0.013404130451596507, 0.01350009093031064, 0.20387304475179713, 0.06615080527343054, 0.08105492826931737, 0.07187697618215338, 0.07051419448248497, 0.07120678841815176, 0.06900352499040117, 0.06773805902985507, 0.06606857887199348, 0.06490003459389815, 0.06329387440046866, 0.062375854223298, 0.06152436355681676, -0.24903467162966028, 0.14452660083521923, 0.09741260807770535, 0.11169347052816828, 0.10878520394095449, 0.10395110389093198, 0.10178286053936177, 0.09845577485023417, 0.09639202754671844, 0.09431089397021285, 0.09227223708187225, 0.09063956287949708, 0.09006337274089139, -6.331331273892488, 0.04959950053938815, 0.21232002152386317, 0.13738973936535515, 0.13805232039217613, 0.13864062364463736, 0.13204996969333513, 0.12780815719312516, 0.12335947748729256, 0.12031124649490947, 0.11655553105224355, 0.11446169821533235, 0.11274058629567958, -6.602569382327371e-26, -0.10285418469335743, 0.16908726129541243, 0.2693141105097407, 0.21452110006694178, 0.1903174495783661, 0.1719668818058185, 0.15959155729638244, 0.15131068311150725, 0.14518777206774192, 0.1390653104350327, 0.13527302258714693, 0.1333180362797432, 10.438540960293794, 1.3163649636685197, 0.4851835872201217, 0.37439440664127777, 0.29212565036770044, 0.24580733226197174, 0.2085914069929107, 0.18827804978127405, 0.17522619949002596, 0.16650636922474327, 0.15788728605858932, 0.15301053134559017, 0.15013271219263513, 0.9037511216694583, 0.8043152853020538, 0.5445325231874552, 0.4213562360182133, 0.3547063935585387, 0.30853127161884075, 0.2577494513786413, 0.22704211482077305, 0.20723947050273006, 0.19442887455242822, 0.1821419503920349, 0.17554857970606708, 0.17174478039033783, 0.38952168822459043, 0.3712727808798683, 0.35558357069406843, 0.33363578823649886, 0.3153730687333256, 0.2989885009327664, 0.2747374187781659, 0.2526613878888383, 0.23570507267273885, 0.2229878640937661, 0.2100695945516243, 0.20251824795695117, 0.19832887044309377, 0.2758733359258758, 0.2644503201933759, 0.2508126256227712, 0.23340686634471197, 0.2261326779014312, 0.2214702176790349, 0.21421429755126514, 0.2095190607694344, 0.20524575112354995, 0.20166136587211886, 0.19726142897464963, 0.19415732602016267, 0.19251673945414774, 0.1851965448021371, 0.21638857849929138, 0.2055269059491991, 0.21877569570251154, 0.21976697657076327, 0.21767504908300334, 0.21567852556140665, 0.20763820267888128, 0.19985582656746362, 0.19326582355738406, 0.18566610849017168, 0.18157782510621492, 0.17546577710681277, 0.17474032663482175, 0.2298864476823823, 0.1833282270267773, 0.207335442346678, -3.520381206188905, -4557.180950580083, -28.39960480414494, -1.1478192498917748e-16, -1.5196296686793787e-18, -4.914243861191939e-24, 1.2624986892487558e-24, -9.224556903049287e-25, -7.846789111943079e-28],
                  "tx": [-0.5153006732249756, -0.5153006732249756, -0.5153006732249756, -0.5153006732249756, 0.45090296721021134, 0.877724083139179, 1.266514380788299, 1.7903256499865483, 2.171944220562842, 2.2548824295883962, 2.59810881677187, 3.1822441093410303, 4.023438586778776, 4.778627815179165, 4.778627815179165, 4.778627815179165, 4.778627815179165],
                  "ty": [-0.1148728912038442, -0.1148728912038442, -0.1148728912038442, -0.1148728912038442, 0.0730565668577187, 0.2371928091064676, 0.23720507882702366, 0.3270380200040733, 0.4554322886562738, 0.598571761777924, 0.6980228094201472, 0.799753505346141, 0.899903642106165, 1.061937382844658, 1.061937382844658, 1.061937382844658, 1.061937382844658],
                  "kx": 3, "ky": 3},
            "T": {"c": [0.046864863359924264, 0.17681724083003525, 0.14163073224818912, 0.15162771894748378, 0.13695472421571805, 0.13356659305490493, 0.12944288687251, 0.12611798260622614, 0.1217221421840352, 0.11741358572987362, 0.11132318419881075, 0.10895535391394602, 0.10392943367176061, 0.25203356964278933, 0.22134907077618537, 0.22619225253115793, 0.21914824216354045, 0.21899690672712352, 0.2162475549452301, 0.21370965870769995, 0.21111150613504434, 0.20869766762722733, 0.2062755587349432, 0.20341486700824288, 0.2011683559173372, 0.20011839296668982, 0.33257791701170036, 0.34513505377766807, 0.33908809374323656, 0.33811518097186877, 0.3346119677456264, 0.33261675984379035, 0.3305320743140296, 0.3284780894259788, 0.3263693097834222, 0.3242630083270774, 0.32171394016010674, 0.3199185163611991, 0.31870416406067936, 0.49508252489206067, 0.48620545569728335, 0.48802441041890676, 0.4852177469958824, 0.4848712028598754, 0.48351492748996666, 0.4822008777223748, 0.48082273361013084, 0.479456764295812, 0.4780490913605275, 0.4763155534741195, 0.47500895063701454, 0.4742483694098181, 0.6225509219052844, 0.5891675307443119, 0.584796980606661, 0.5888898462017581, 0.5879936534032628, 0.5887705016080883, 0.589001462266826, 0.5891216406703144, 0.5889398575690377, 0.5886288294806572, 0.5880840676133126, 0.5876161629374262, 0.5871968488561843, -8.354182299972637, 0.6334046145500632, 0.6420896661252834, 0.6520517676106181, 0.6623266144818326, 0.6670897537783262, 0.6714335227283733, 0.6746517220450446, 0.6774330526790386, 0.6796060671307536, 0.681772893103191, 0.6828486456403006, 0.6834852455314933, -5.256869465155489, 0.5069848790375531, 0.5536520827378589, 0.6308396888031902, 0.678715336090963, 0.7056837781081121, 0.7239791854626603, 0.7369151037921956, 0.7467624703218283, 0.7544648467021235, 0.7620223593861031, 0.7661964637910653, 0.7685081229944577, -0.13610541743321392, 0.2984164334284287, 0.5237491724132731, 0.641867701606683, 0.696180483034638, 0.7347248641411003, 0.7637469735703932, 0.7860723976076851, 0.8036528365247397, 0.8177812383944373, 0.8317130691722759, 0.8395079832123419, 0.8438109640713454, 0.5060670665819913, 0.5693411613434591, 0.6557077560003108, 0.7301945470693596, 0.7772920444566501, 0.812348410109175, 0.8406555558565253, 0.8640746613913751, 0.883682925965483, 0.9003452406154429, 0.9175282487782662, 0.9276316667777383, 0.9331381362817789, 0.7727851826520347, 0.8082806787171677, 0.84538508595395, 0.8895930763922877, 0.9175731110616622, 0.9419951891987514, 0.963378038870992, 0.9820156965171196, 0.9983092680048019, 1.012704454356697, 1.028134151869983, 1.0378141326894659, 1.0435736207606063, 1.0555625056247198, 1.0573524034807775, 1.0780741784321002, 1.097712866707338, 1.1156246284299336, 1.1302843039783168, 1.1433169761836446, 1.1557134650047103, 1.1672122176964743, 1.1780239057782915, 1.1900050629298564, 1.1971732267509216, 1.1999577915532922, 1.1964064574486037, 1.2295515005902171, 1.234220090966577, 1.2601914281072637, 1.2674034944811685, 1.2764164547044248, 1.2890528118987377, 1.2972120518368038, 1.3027048744701275, 1.3029001818095745, 1.2965347553503495, 1.3030902418348689, 1.3941742818868987, 1.3637233668486184, 1.3094542871166297, 1.3427508199968088, 1.3322909179932338, 0.5644135725576785, 7.483668653049959e-23, 7.528132077440272e-24, 7.20352558518845e-26, -1.9983479767829612e-26, 8.074272339521952e-26, -1.0541103700816169e-26, 6.218969923049791e-25, 3.4590329375704226e-25],
                  "tx": [-0.5169583072705795, -0.5169583072705795, -0.5169583072705795, -0.5169583072705795, 0.45231849338926533, 0.9016756119766755, 1.3708519001412245, 1.8832303190754902, 2.23276365974874, 2.690997626474903, 3.1464649710263743, 3.5924551832363476, 4.050052822288748, 4.778719905959477, 4.778719905959477, 4.778719905959477, 4.778719905959477],
                  "ty": [-0.11487888044342434, -0.11487888044342434, -0.11487888044342434, -0.11487888044342434, 0.07888220939902872, 0.1939025571808101, 0.2964012224809535, 0.3977890450216087, 0.4999166970612849, 0.5998591432446483, 0.699993149511336, 0.7999896307557478, 0.8999998026749798, 1.0619377155801903, 1.0619377155801903, 1.0619377155801903, 1.0619377155801903],
                  "kx": 3, "ky": 3},
            "d": {"c": [690.9514656495783, 977.9274396694071, 853.3887408694592, 907.6124836417913, 927.0914359266344, 931.4643456811074, 935.7030926056353, 940.0982323447441, 945.4287948064912, 955.130352762907, 969.6307464097592, 975.5893646214057, 992.7592709297395, 1043.743816701568, 1011.2887543518445, 1037.2037293505264, 1040.1972951174282, 1044.1288902895672, 1047.2598270072285, 1049.2991939369404, 1052.0572958471853, 1055.3442413664857, 1060.082285017783, 1065.4643922779635, 1069.5445112567093, 1071.613196714949, 991.8436394928467, 1014.6541042864847, 1014.1233729245123, 1025.395421705915, 1029.9254963334668, 1033.0284401283238, 1034.8882082695893, 1037.4116061712439, 1040.3481405707198, 1044.6170339847276, 1049.4636673918885, 1052.9759727357732, 1055.242191128244, 876.5751200710883, 872.9511762089764, 891.9158679268342, 903.4328386797082, 910.1140228809459, 914.6550987186309, 917.5306640888001, 921.3282392169356, 925.757447026974, 932.0212192918144, 939.0260238369106, 944.0069270105248, 946.9681870753615, 688.464048232878, 732.1564796482858, 742.9420238982698, 767.94875363588, 778.1391426595466, 785.4581073919296, 789.6084843867485, 795.3386162384537, 801.8291601737441, 810.9705755535217, 821.0048518140433, 828.045280757283, 832.3098647539709, 429.2441110482046, 439.97814514295675, 534.6967713011643, 577.1572003674736, 600.721625861026, 613.9176019018262, 622.6473428077361, 633.2218399425769, 645.2617771399931, 661.0111472770386, 677.7672082485498, 688.8244862904453, 695.4671949188738, 20.70942859543173, -122.30540884041108, 293.3792008751352, 418.7946533507418, 462.6689554281062, 487.7422056680588, 501.15700009884864, 518.2999524703049, 536.2338348103154, 558.8091237271645, 581.8422124723822, 596.7140501057839, 605.3428353584939, -86.90548144290244, 1.8582940356135869, 124.83411591013673, 247.79099729922163, 303.06552231834985, 334.7139097324849, 353.2987528446524, 376.1914606380927, 400.6828329212754, 430.9126067095897, 461.3634772253174, 480.4171779553588, 491.5960307437596, -40.94245576614391, -4.458245584820759, 71.72674262467001, 151.89966809162416, 188.2499482535848, 215.2968759452414, 230.577274020056, 251.6313765838545, 275.14750558771374, 306.8507507389638, 340.28605744467586, 362.4470164644032, 375.1011002570475, -32.85175919413962, 0.9621580125778753, 46.04616150184186, 97.83474425814413, 126.22955669661779, 143.64350260595958, 155.09369139187677, 169.66242619001912, 186.67311442715757, 210.5076994766416, 236.8340900785181, 255.08954531456013, 266.1499825148007, -21.45939356086304, -0.5195861767068282, 32.83257586056632, 71.92976166709146, 86.94971658796453, 101.47926623098671, 109.17837634087641, 120.80673986300697, 134.3653646989685, 153.8408299535766, 175.74614024402672, 191.31555327879295, 200.68540054524408, -19.276287571903907, -1.6380797306700425, 33.40107886911538, 59.79815727719327, 96.61449957284567, 107.48343734225818, 118.64856132034112, 130.26169215480527, 139.67462659398012, 155.09699714070118, 165.33059384296538, 180.49334665941265, 177.01333329618524, -24.837583943949593, 8.322489695367791, 12.785156669898797, 66.17582015637757, 9.16427047958048e-21, 5.582234870747306e-22, 8.090079455977564e-24, 3.302278317051351e-23, -1.835554760513402e-23, 1.3534080847910838e-22, -6.738135105790284e-23, 4.1635394429088e-22, 3.368032301624119e-22],
                  "tx": [-0.5170458231932354, -0.5170458231932354, -0.5170458231932354, -0.5170458231932354, 0.31875067353751885, 0.7958802275576966, 1.3929954252108299, 1.800521253230898, 2.256170775053383, 2.256171097872649, 2.9047020273438755, 3.4656339022252403, 4.051457939046947, 4.77872476795518, 4.77872476795518, 4.77872476795518, 4.77872476795518],
                  "ty":  [-0.11490096679075182, -0.11490096679075182, -0.11490096679075182, -0.11490096679075182, 0.23303943654463818, 0.3813675135971326, 0.461189627289363, 0.5308694617794865, 0.5908905777914959, 0.5927807413677489, 0.7084367001231848, 0.8007884800052111, 0.9003544112515153, 1.0619389425994863, 1.0619389425994863, 1.0619389425994863, 1.0619389425994863],
                  "kx": 3, "ky": 3}}
scaling = {'h': 1e-6, 'P': 1e-8, 'd': 1., 'T': 1e-3, 'v': 1e-5}


# ---------------------------------------------------------------------------------------------------------------------
# THERMODYNAMIC TOOLS

def _power_array(value, combination):
    """
    Calculates array of powers of 'value', using the specified list of combinations to use
    to calculate them. This was written by Adrian Croucher, in PyTOUGH implementation
    of IAPWS .
    """

    ppowers = [item[0] for item in combination if item[0] > 0]
    # for simplicity, always calculate -1st power (usually need it anyway):
    npowers = [item[0] for item in combination if item[0] < 0] + [-1]
    nneg, npos = -min(npowers), max(ppowers)
    # store negative powers at end of array, so can use negative indexing:
    p = numpy.zeros(1 + npos + nneg)
    p[0], p[1], p[-1] = 1.0, value, 1.0 / value
    for c in combination:
        p[c[0]] = p[c[1][0]]
        for mult in c[1][1:]:
            p[c[0]] *= p[mult]
    return p


def _power_array_diff(value, orders):
    """
    Calculates array of powers of 'value' first order derivative.
    """

    p = numpy.zeros(2 + max(orders))
    p[0], p[1] = 0., 1.
    orders= sorted(orders)
    for o in orders:
        p[o+1] = (o+1) * value ** o
    return p


def _visc(d, t):
    """
    Computes dynamic viscosity of water or steam, given the density
    d and temperature t, using the IAPWS industrial formulation 2008.
    Critical enhancement of viscosity near the critical point is not included.
    This was written by Adrian Croucher, in PyTOUGH implementation
    of IAPWS.
    """

    tau = t / TCRIT
    delta = d / DCRIT

    tauipow = _power_array(1. / tau, ticv)
    tspow = _power_array(tauipow[1] - 1., tscv)
    dspow = _power_array(delta - 1., dscv)

    # Viscosity in dilute-gas limit:
    s0 = numpy.dot(h0v, tauipow[0:4])
    mu0 = 100. * numpy.sqrt(tau) / s0

    # Contribution due to finite density:
    s1 = sum([tspow[i] * h * dspow[j] for (i, j, h) in zip(ivs, jvs, h1v)])

    mu1 = exp(delta * s1)
    visc = mustar * mu0 * mu1
    return visc


def _visc_diff(d, t):
    """
    Computes the first order derivatives of the dynamic viscosity of water or steam, given the density
    d and temperature t, using the IAPWS industrial formulation 2008.
    Critical enhancement of viscosity near the critical point is not included.
    This was written by Adrian Croucher, in PyTOUGH implementation
    of IAPWS.
    """

    tau = t / TCRIT
    delta = d / DCRIT

    d_tauipow = _power_array_diff(1. / tau, [1,2])
    d_tspow = _power_array_diff(d_tauipow[1] - 1., [1,2,3,4])
    d_dspow = _power_array_diff(delta - 1., [1,2,3,4,5])

    tauipow = _power_array(1. / tau, ticv)
    tspow = _power_array(tauipow[1] - 1., tscv)
    dspow = _power_array(delta - 1., dscv)

    # Viscosity in dilute-gas limit:
    s0 = numpy.dot(h0v, tauipow[0:4])
    mu0 = 100. * numpy.sqrt(tau) / s0

    ds0dT = numpy.dot(h0v, d_tauipow[0:4])
    dmu0dT = 100. * ((s0 / (TCRIT * numpy.sqrt(tau)) - ds0dT * numpy.sqrt(tau)) / s0 ** 2)

    # Contribution due to finite density:
    ds1dT = sum([d_tspow[i] * h * dspow[j] for (i, j, h) in zip(ivs, jvs, h1v)])
    ds1dd = sum([tspow[i] * h * d_dspow[j] for (i, j, h) in zip(ivs, jvs, h1v)])

    s1 = sum([tspow[i] * h * dspow[j] for (i, j, h) in zip(ivs, jvs, h1v)])
    mu1 = exp(delta * s1)

    dmu1dT = delta * ds1dT * exp(delta * s1)
    dmu1dd = (delta * ds1dd + s1 / DCRIT) * exp(delta * s1)
    visc = mustar * mu0 * mu1
    dvdT = - (mustar * (dmu0dT * mu1 + dmu1dT * mu0)) / (visc ** 2)
    dvdd = - (mustar * mu0 * dmu1dd) / (visc ** 2)
    return dvdT, dvdd


def _convert_T_to_h(p, T):
    """
    Converts a temperature into the corresponding value of enthalpy, knowing the value of pressure. This code is based
    on the Methodica implementation of water thermodynamics in C. I have only translated the code into Python.
    :param p: Float, Value of pressure
    :param T: Float, Value of temperature
    :return: float, value of enthalpy
    """
    region = _region_pT(p, T)
    if region == 1:
        _, gtau, tau= _g1(p,T)
        h = RH2O * T * tau * gtau
    elif region == 2:
        _, gtau, tau = _g2(p, T)
        h = RH2O * T * tau * gtau
    elif region == 3:
        d, error = _dofpt3(p=p, T=T, delp=1.0e-7)
        tau, ftau, delta, fdelta, _ = _f3(d, T)
        h = RH2O * T * (tau * ftau + delta * fdelta)
    elif region == 5:
        gtau, tau = _g5(p, T)
        h = RH2O * T * tau * gtau
    else: h = numpy.nan
    return h


def _g1(p, T):
    """
    Gibbs Function for region 1. Yields G(p,T). This code is based
    on the Methodica implementation of water thermodynamics in C. I have only translated the code into Python.
    :param p: Float, Value of pressure
    :param T: Float, Value of temperature
    :return: float, Characteristic temperature and Derivative of the Gibbs function with respect to the characteristic
        temperature.
    """

    pi = p / PSTAR1
    tau = TSTAR1 / T
    pi1 = 7.10 - pi
    tau1 = -1.2220 + tau
    o = numpy.zeros(45)
    o[0]= tau1 * tau1
    o[1]= o[0] * o[0]
    o[2]= o[1] * o[1]
    o[3]= o[2] * tau1
    o[4]= 1 / o[3]
    o[5]= o[0] * o[1]
    o[6]= o[0] * tau1
    o[7]= 1 / o[6]
    o[8]= o[0] * o[1] * o[2]
    o[9]= 1 / o[1]
    o[10]= o[1] * tau1
    o[11]= 1 / o[10]
    o[12]= o[1] * o[2]
    o[13]= 1 / o[2]
    o[14]= pi1 * pi1
    o[15]= o[14] * pi1
    o[16]= o[14] * o[14]
    o[17]= o[16] * o[16]
    o[18]= o[16] * o[17] * pi1
    o[19]= o[14] * o[16]
    o[20]= o[2] * o[2]
    o[21]= o[20] * o[20]
    o[22]= o[21] * o[2] * tau1
    o[23]= 1 / o[22]
    o[24]= o[21] * o[2]
    o[25]= 1 / o[24]
    o[26]= o[0] * o[1] * o[21] * tau1
    o[27]= 1 / o[26]
    o[28]= o[0] * o[1] * o[21]
    o[29]= 1 / o[28]
    o[30]= o[0] * o[1] * o[20] * o[2] * tau1
    o[31]= 1 / o[30]
    o[32]= o[1] * o[20] * o[2] * tau1
    o[33]= 1 / o[32]
    o[34]= o[0] * o[2] * tau1
    o[35]= 1 / o[34]
    o[36]= o[0] * o[2]
    o[37]= 1 / o[36]
    o[38]= 1 / o[5]
    o[39]= o[0] * o[21] * o[2]
    o[40]= 1 / o[39]
    o[41]= 1 / o[21]
    o[42]= o[0] * o[1] * o[20] * o[2]
    o[43]= 1 / o[42]
    o[44]= 1 / o[12]

    gtau = pi1*(o[37]*(-0.00254871721114236 + o[0]*(0.0042494411096112+ (0.0189900682184190 + (-0.0218417171754140 - 0.000158515073909790*o[0])*o[0])*o[5])) + pi1*(o[9]*(0.00141552963219801 + o[1]*(0.000047661393906987 + o[0]*(-0.0000132425535992538 -1.23581493705910e-14*o[8]))) + pi1*(o[11]*(0.000126718579380216 -5.1123076872062e-9*o[36]) + pi1*(o[38]*(0.0000112126409540000 + (1.30342445791202e-6 - 1.43417299379240e-12*o[12])*o[6]) + pi1*(3.2413597488094e-6*o[4] + o[15]*((1.40077319158051e-8 +1.04549227383804e-9*o[10])*o[44] + o[18]*(1.99410180757040e-17*o[43]+ o[14]*(-4.4882754268415e-19*o[41] + o[19]*(-1.00075970318621e-21*o[27] + pi1*(4.6595728296277e-22*o[25] + pi1*(-7.2912378325616e-23*o[23]+ 3.8350205789908e-24*o[40]*pi1))))))))))) + o[7]*(-0.292659424263340+ tau1*(0.84548187169114 + o[0]*(3.3855169168385 + tau1*(-1.91583926775744+ tau1*(0.47316115539684 + (-0.066465668798004 + 0.0040607314991784*tau1)*tau1)))))
    gtautau = pi1*(o[35]*(0.0254871721114236 + o[0]*(-0.033995528876889+ (-0.037980136436838 - 0.00031703014781958*o[1])*o[5])) + pi1*(o[11]*(-0.0056621185287920 + o[5]*(-0.0000264851071985076 -1.97730389929456e-13*o[8])) + pi1*((-0.00063359289690108 -2.55615384360309e-8*o[36])*o[38] + pi1*(pi1*(-0.0000291722377392842*o[37] + o[15]*(o[18]*(-5.9823054227112e-16*o[31] + o[14]*(o[19]*(3.9029628424262e-20*o[25] + pi1*(-1.86382913185108e-20*o[23] + pi1*(2.98940751135026e-21*o[40] - (1.61070864317613e-22*pi1)/(o[0]*o[21]*o[2]*tau1)))) + 1.43624813658928e-17/(o[21]*tau1))) + (-1.68092782989661e-7- 7.3184459168663e-9*o[10])/(o[1]*o[2]*tau1))) + (-0.000067275845724000+ (-3.9102733737361e-6 - 1.29075569441316e-11*o[12])*o[6])/(o[0]*o[1]*tau1))))) + o[9]*(0.87797827279002 + tau1*(-1.69096374338228 + o[6]*(-1.91583926775744 + tau1*(0.94632231079368 + (-0.199397006394012 +0.0162429259967136*tau1)*tau1))))

    return gtautau, gtau, tau


def _g2(p, T):
    """
    Gibbs Function for region 2. Yields G(p,T). This code is based
    on the Methodica implementation of water thermodynamics in C. I have only translated the code into Python.
    :param p: Float, Value of pressure
    :param T: Float, Value of temperature
    :return: float, Characteristic temperature and Derivative of the Gibbs function with respect to the characteristic
        temperature.
    """

    pi = p / PSTAR2
    tau = TSTAR2 / T
    tau2 = -0.5 + tau
    o = numpy.zeros(55)
    o[0]= tau2 * tau2
    o[1]= o[0] * tau2
    o[2]= -0.050325278727930 * o[1]
    o[3]= -0.057581259083432 + o[2]
    o[4]= o[3] * tau2
    o[5]= -0.045996013696365 + o[4]
    o[6]= o[5] * tau2
    o[7]= -0.0178348622923580 + o[6]
    o[8]= o[7] * tau2
    o[9]= o[0] * o[0]
    o[10]= o[9] * o[9]
    o[11]= o[10] * o[10]
    o[12]= o[9] * o[10] * o[11] * tau2
    o[13]= o[0] * o[9] * tau2
    o[14]= o[9] * o[10] * tau2
    o[15]= o[0] * o[11] * tau2
    o[16]= o[0] * o[10] * tau2
    o[17]= o[0] * o[9] * o[10]
    o[18]= o[9] * o[10] * o[11]
    o[19]= o[0] * o[9]
    o[20]= pi * pi
    o[21]= o[20] * o[20]
    o[22]= o[20] * o[21]
    o[23]= o[9] * o[11] * tau2
    o[24]= o[11] * o[11]
    o[25]= o[10] * o[11] * o[24] * tau2
    o[26]= o[9] * o[11]
    o[27]= o[0] * o[9] * o[10] * tau2
    o[28]= o[9] * o[11] * o[24] * tau2
    o[29]= o[0] * o[9] * o[24] * tau2
    o[30]= o[0] * o[10] * o[11]
    o[31]= o[0] * o[11]
    o[32]= tau * tau
    o[33]= o[32] * o[32]
    o[34]= -0.000053349095828174 * o[12]
    o[35]= -0.087594591301146 + o[34]
    o[36]= o[1] * o[35]
    o[37]= -0.0078785554486710 + o[36]
    o[38]= o[0] * o[37]
    o[39]= -0.00037897975032630 + o[38]
    o[40]= o[39] * tau2
    o[41]= -0.000066065283340406 + o[40]
    o[42]= o[41] * tau2
    o[43]= 5.7870447262208e-6 * tau2
    o[44]= -0.301951672367580 * o[1]
    o[45]= -0.172743777250296 + o[44]
    o[46]= o[45] * tau2
    o[47]= -0.091992027392730 + o[46]
    o[48]= o[47] * tau2
    o[49]= o[0] * o[10]
    o[50]= o[9] * o[10]
    o[51]= o[10] * o[11] * o[24]
    o[52]= o[9] * o[11] * o[24]
    o[53]= o[0] * o[9] * o[24]
    o[54]= o[10] * o[11] * tau2

    gtau = (0.0280439559151000 + tau*(-0.285810955258200 + tau*(1.22131494717840 + tau*(-2.84816394288800 + tau*(4.3839511194500+ o[32]*(10.0866556801800 + (-0.56817265215440 + 0.063805390599210*tau)*tau))))))/(o[32]*o[33]) + pi*(-0.0178348622923580 + o[48] + pi*(-0.000033032641670203 + (-0.00037897975032630 + o[0]*(-0.0157571108973420+ (-0.306581069554011 - 0.00096028372490713*o[12])*o[1]))*tau2 + pi*(4.3870667284435e-7 + o[0]*(-0.000096833031715710 + (-0.0090203547252888- 1.42338887469272*o[12])*o[1]) + pi*(-7.8847309559367e-10 + pi*(0.0000160454534363627*o[19] + pi*(o[0]*(-5.0144299353183e-11 + o[14]*(-0.033874355714168 - 836.35096769364*o[15])) + pi*((-0.0000138839897890111- 0.97367106089347*o[17])*o[49] + pi*(o[13]*(9.0049690883672e-11- 296.320827232793*o[18]) + pi*(2.57526266427144e-7*o[50] + pi*(o[1]*(4.1627860840696e-19 + (-1.02347470959290e-12 -1.40254511313154e-8*o[9])*o[19]) + o[22]*(o[18]*(-2.34560435076256e-9+ 5.3465159397045*o[23]) + o[20]*(-19.1874828272775*o[51] + o[20]*(o[15]*(1.78371690710842e-23 + (1.07202609066812e-11 -0.000201611844951398*o[14])*o[27]) + pi*(-1.24017662339842e-24*o[26]+ pi*(0.000200482822351322*o[52] + pi*(-4.9797574845256e-14*o[53]+ (1.90027787547159e-27 + o[17]*(2.21658861403112e-15 -0.000054734430199902*o[31]))*o[54]*pi)))))))))))) + (2.55814357045700e-8 + 1.44676118155521e-6*tau2)*tau2))))
    gtautau = (-0.168263735490600 + tau*(1.42905477629100 + tau*(-4.8852597887136+ tau*(8.5444918286640 + tau*(-8.7679022389000 + o[32]*(-0.56817265215440+ 0.127610781198420*tau)*tau)))))/(o[32]*o[33]*tau) + pi*(-0.091992027392730+ (-0.34548755450059 - 1.50975836183790*o[1])*tau2 + pi*(-0.00037897975032630+ o[0]*(-0.047271332692026 + (-1.83948641732407 - 0.033609930371750*o[12])*o[1]) + pi*((-0.000193666063431420 + (-0.045101773626444 -48.395221739552*o[12])*o[1])*tau2 + pi*(2.55814357045700e-8 +2.89352236311042e-6*tau2 + pi*(0.000096272720618176*o[9]*tau2 + pi*((-1.00288598706366e-10 + o[14]*(-0.50811533571252 -28435.9329015838*o[15]))*tau2 + pi*(o[10]*(-0.000138839897890111 -23.3681054614434*o[17])*tau2 + pi*((6.3034783618570e-10 -10371.2289531477*o[18])*o[19] + pi*(3.09031519712573e-6*o[16] + pi*(o[0]*(1.24883582522088e-18 + (-9.2112723863361e-12 -1.82330864707100e-7*o[9])*o[19]) + o[22]*(o[0]*o[10]*o[11]*(-6.5676921821352e-8+ 261.979281045521*o[23])*tau2 + o[20]*(-1074.49903832754*o[0]*o[9]*o[11]*o[24]*tau2 + o[20]*((3.3890621235060e-22 + (3.6448887082716e-10 - 0.0094757567127157*o[14])*o[27])*o[31] + pi*(-2.48035324679684e-23*o[15] + pi*(0.0104251067622687*o[0]*o[11]*o[24]*tau2 + pi*(o[10]*o[11]*(4.7506946886790e-26 + o[17]*(8.6446955947214e-14 - 0.00311986252139440*o[31]))*pi -1.89230784411972e-12*o[9]*o[24]*tau2))))))))))))))))
    return gtautau, gtau, tau


def _g5(p, T):
    """
    Gibbs Function for region 5. Yields G(p,T). This code is based
    on the Methodica implementation of water thermodynamics in C. I have only translated the code into Python.
    :param p: Float, Value of pressure
    :param T: Float, Value of temperature
    :return: float, Characteristic temperature and Derivative of the Gibbs function with respect to the characteristic
        temperature.
    """

    pi = p / PSTAR5
    tau = TSTAR5 / T
    o = numpy.zeros(11)
    o[0]= tau * tau
    o[1]= -0.0045942820899910 * o[0]
    o[2]= 0.00217746787145710 + o[1]
    o[3]= o[2] * tau
    o[4]= o[0] * tau
    o[5]= o[0] * o[0]
    o[6]= o[5] * o[5]
    o[7]= o[6] * tau
    o[8]= -7.9449656719138e-6 * o[7]
    o[9]= pi * pi
    o[10]= -0.0137828462699730 * o[0]

    gtau = pi*(0.00217746787145710 + o[10] + pi*(-0.000035752345523612*o[6] + 3.8757684869352e-7*o[0]*pi)) + (0.074415446800398 + tau*(-0.73803069960666 + (3.11613182139250 + o[0]*(6.8540841634434 -0.65923253077834*tau))*tau))/o[5]

    return gtau, tau


def _f3(d,T):
    """
        Helmholtz function for region 3: f(d,T). This code is based
        on the Methodica implementation of water thermodynamics in C. I have only translated the code into Python.
        :param p: Float, Value of pressure
        :param T: Float, Value of temperature
        :return: float, Characteristic temperature and Derivative of the Gibbs function with respect to the characteristic
            temperature.
        """

    tau = TCRIT/T
    if d == DCRIT and T == TCRIT:
        delta = 1- eps
    else:
        delta = abs(d/DCRIT)
    # print delta
    o = numpy.zeros(40)
    o[0]= tau * tau
    o[1]= o[0] * o[0]
    o[2]= o[1] * tau
    o[3]= o[0] * tau
    o[4]= o[1] * o[1]
    o[5]= o[0] * o[4] * tau
    o[6]= o[4] * tau
    o[7]= -0.64207765181607 * o[0]
    o[8]= 0.88521043984318 + o[7]
    o[9]= o[6] * o[8]
    o[10]= -1.15244078066810 + o[9]
    o[11]= o[10] * o[1]
    o[12]= -1.26543154777140 + o[11]
    o[13]= o[0] * o[12]
    o[14]= o[0] * o[1] * o[4] * tau
    o[15]= o[1] * o[4]
    o[16]= o[0] * o[4]
    o[17]= o[4] * o[4]
    o[18]= o[0] * o[17] * o[1]
    o[19]= o[0] * o[17] * o[1] * tau
    o[20]= o[17] * o[4]
    o[21]= o[0] * o[17] * o[4]
    o[22]= 0.251168168486160 * o[1]
    o[23]= 0.078841073758308 + o[22]
    o[24]= o[14] * o[23]
    o[25]= -6.1005234513930 + o[24]
    o[26]= o[25] * tau
    o[27]= 9.7944563083754 + o[26]
    o[28]= o[1] * o[27]
    o[29]= -1.70429417648412 + o[28]
    o[30]= o[0] * o[29]
    o[31]= delta * delta
    o[32]= -10.9153200808732 * o[0]
    o[33]= 13.2781565976477 + o[32]
    o[34]= o[33] * o[6]
    o[35]= -6.9146446840086 + o[34]
    o[36]= o[1] * o[35]
    o[37]= -2.53086309554280 + o[36]
    o[38]= o[37] * tau
    o[39]= o[17] * o[4] * tau

    fdelta = (1.06580700285130 + delta*(o[13] + delta*(0.76986920373342 + o[30] + delta*(-0.83997989096130 + o[0]*(4.1699398708380 + o[0]*(-6.0569745070710 + o[15]*(-0.0246442911521889- 1.42788107204769*o[16]))) + delta*(0.175936297894000 + o[0]*(-1.77905741714956+ o[0]*(3.6228828287893 + 2.82089800351868*o[18])) + delta*(delta*(-0.133052405238576 + o[0]*(0.56556450999055 + 0.98617670687766*o[20])+ delta*(-0.094523605689436*o[0] + delta*(-0.118674762819776*o[21] + delta*(o[0]*(0.0052130658265276 + 0.0290780142333399*o[20])+ delta*(0.00080964802996215 - 0.00049416288967996*delta*o[21]- 0.00165576797950370*tau))))) + (0.53852563131660 + o[0]*(-1.64568116294770- 2.54355310205790*o[19]))*tau))))))/delta
    fdeltadelta = (-1.06580700285130 + o[31]*(0.76986920373342 + o[30]+ delta*(-1.67995978192260 + o[0]*(8.3398797416760 + o[0]*(-12.1139490141420+ o[15]*(-0.049288582304378 - 2.85576214409538*o[16]))) + delta*(0.52780889368200 + o[0]*(-5.3371722514487 + o[0]*(10.8686484863680 +8.4626940105560*o[18])) + delta*(delta*(-0.66526202619288 + o[0]*(2.82782254995276 + 4.9308835343883*o[20]) + delta*(-0.56714163413662*o[0] + delta*(-0.83072333973843*o[21] + delta*(o[0]*(0.041704526612220 + 0.232624113866719*o[20]) + delta*(0.0072868322696594 - 0.0049416288967996*delta*o[21] -0.0149019118155333*tau))))) + (2.15410252526640 + o[0]*(-6.5827246517908- 10.1742124082316*o[19]))*tau)))))/o[31]
    ftau = 20.9443969743070 + (-15.3735415757432 + o[2]*(18.3301634515678 + o[3]*(-28.0807811486200 + o[0]*(14.4640436358204- 0.194503669468755*o[5]))))*tau + delta*(o[38] + delta*(tau*(-1.70429417648412 + o[1]*(29.3833689251262 + (-21.3518320798755 + o[14]*(0.86725181134139 + 3.2651861903201*o[1]))*tau)) + delta*((2.77995991389200 + o[0]*(-8.0759660094280 + o[15]*(-0.131436219478341- 12.3749692910800*o[16])))*tau + delta*((-0.88952870857478 + o[0]*(3.6228828287893 + 18.3358370228714*o[18]))*tau + delta*(0.107705126263320 + o[0]*(-0.98740869776862 - 13.2264761307011*o[19])+ delta*((0.188521503330184 + 4.2734323964699*o[20])*tau + delta*(-0.0270067444826960*tau + delta*(-0.38569297916427*o[39] + delta*(delta*(-0.000165576797950370 - 0.00116802137560719*delta*o[39])+ (0.00115845907256168 + 0.084003152229649*o[20])*tau)))))))))

    return tau, ftau, delta, fdelta, fdeltadelta


def _d2n(p,T):
    """
    Density in region 2 as function of p and T. This code is based
    on the Methodica implementation of water thermodynamics in C. I have only translated the code into Python.
    """

    pi = p/PSTAR2
    tau = TSTAR2/T
    tau2 = tau - 0.5
    o = numpy.zeros(12)
    o[0]= tau2 * tau2
    o[1]= o[0] * tau2
    o[2]= o[0] * o[0]
    o[3]= o[2] * o[2]
    o[4]= o[3] * o[3]
    o[5]= o[2] * o[3] * o[4] * tau2
    o[6]= o[2] * o[3] * tau2
    o[7]= o[0] * o[2] * o[3]
    o[8]= pi * pi
    o[9]= o[8] * o[8]
    o[10]= o[2] * o[4] * tau2
    o[11]= o[4] * o[4]

    gpi = (1. + pi*(-0.0017731742473213 + tau2*(-0.017834862292358 + tau2*(-0.045996013696365 + (-0.057581259083432 - 0.05032527872793*o[1])*tau2)) + pi*(tau2*(-0.000066065283340406 + (-0.0003789797503263 + o[0]*(-0.007878555448671 + o[1]*(-0.087594591301146 -0.000053349095828174*o[5])))*tau2) + pi*(6.1445213076927e-8 + (1.31612001853305e-6 + o[0]*(-0.00009683303171571 + o[1]*(-0.0045101773626444- 0.122004760687947*o[5])))*tau2 + pi*(tau2*(-3.15389238237468e-9 +(5.116287140914e-8 + 1.92901490874028e-6*tau2)*tau2) + pi*(0.0000114610381688305*o[0]*o[2]*tau2 + pi*(o[1]*(-1.00288598706366e-10+ o[6]*(-0.012702883392813 - 143.374451604624*o[0]*o[4]*tau2)) + pi*(-4.1341695026989e-17 + o[0]*o[3]*(-8.8352662293707e-6 -0.272627897050173*o[7])*tau2 + pi*(o[3]*(9.0049690883672e-11 -65.8490727183984*o[2]*o[3]*o[4]) + pi*(1.78287415218792e-7*o[6] + pi*(o[2]*(1.0406965210174e-18 + o[0]*(-1.0234747095929e-12 -1.0018179379511e-8*o[2])*o[2]) + o[9]*o[8]*((-1.29412653835176e-9 +1.71088510070544*o[10])*o[5] + o[8]*(-6.05920510335078*o[11]*o[3]*o[4]*tau2 + o[8]*(o[2]*o[4]*(1.78371690710842e-23 + o[0]*o[2]*o[3]*(6.1258633752464e-12 - 0.000084004935396416*o[6])*tau2) + pi*(-1.24017662339842e-24*o[10] + pi*(0.0000832192847496054*o[11]*o[2]*o[4]*tau2 + pi*(o[0]*o[3]*o[4]*(1.75410265428146e-27 + (1.32995316841867e-15 -0.0000226487297378904*o[0]*o[4])*o[7])*pi - 2.93678005497663e-14*o[0]*o[11]*o[2]*tau2)))))))))))))))))/pi
    d = p / (RH2O*T*pi*gpi)

    return d


def _Helmholtz_pT(d, T):
    """
    Function to calculate analytic derivatives for computing p and h given d and t.This code is based
    on the Methodica implementation of water thermodynamics in C. I have only translated the code into Python.
    """

    _, _, delta, fdelta, fdeltadelta = _f3(d, T)
    p = d*RH2O*T*delta*fdelta
    pd = RH2O*T*delta*(2.0*fdelta + delta*fdeltadelta)

    return p, pd


def _dofpt3(p, T, delp):
    """
    Inverse iteration in region 3: (d) = f(p,T).This code is based
    on the Methodica implementation of water thermodynamics in C. I have only translated the code into Python.
    """

    found = False
    i = 0
    error = 0
    supercritical = False
    if p > PCRIT:
        supercritical = True
    damping = 1.0
    Tmax = _b23t(p)

    if supercritical:
        dmax = _dofp13(p)
        dmin = _dofp23(p)
        dguess = dmax - (T - TLIMIT1)/(Tmax - TLIMIT1)*(dmax-dmin)

    else:
        liquid = False
        if T < _t_sat(p):
            liquid = True
        if liquid:
            dmax = _dofp13(p)
            dmin = _rhol_p_R4b(p)
            dguess = 1.1*rhol_T(T)
        else:
            dmax = _rhov_p_R4b(p)
            dmin = _dofp23(p)
            dguess = 0.9*_rhov_T(T)
    while i < IMAX and not found:
        d = dguess
        phelm, pd = _Helmholtz_pT(d, T)
        dp = phelm - p
        # print abs(dp/p)
        if abs(dp/p) <= delp:
            found = True
        else:
            deld = dp/pd*damping
            d = d - deld
            if dmin < d < dmax:
                dguess = d
            else:
                if d > dmax:
                    dguess = dmax - numpy.sqrt(eps)
                else:
                    dguess = dmin + numpy.sqrt(eps)
        i += 1
    if not found:
        error = 1
        print("Error in inverse function _dofpt3: iteration failed, p = " + str(p) + " ,T = " + str(T) + ", d = " + str(d))
        # d = numpy.inf
    # print dmax, dmin, d, T
    return d, error


def _rhov_T(T):
    """
    Density of saturated vapour. This code is based
    on the Methodica implementation of water thermodynamics in C. I have only translated the code into Python.
    """

    p = _sat(T)
    if T < TLIMIT1:
        d = _d2n(p,T)
    elif T < TCRIT:
        d = _rhov_p_R4b(p)
    else:
        d = DCRIT

    return d


def _rhol_p_R4b(p):
    """
    Explicit approximation of vapour density on the boundary between 4 and 3. This code is based
    on the Methodica implementation of water thermodynamics in C. I have only translated the code into Python.
    """

    if p < PCRIT:
        x = acos(p/PCRIT)
        dl = (1 + x*(1.903224079094824 + x*(-2.5314861802401123 + x*(-8.191449323843552+ x*(94.34196116778385 + x*(-369.3676833623383 + x*(796.6627910598293 + x*(-994.5385383600702 + x*(673.2581177021598 +(-191.43077336405156 + 0.00052536560808895*x)*x)))))))))*DCRIT
    else:
        dl = DCRIT
    return dl


def _rhov_p_R4b(p):
    """
    Explicit approximation of vapour density on the boundary between 4 and 2. This code is based
    on the Methodica implementation of water thermodynamics in C. I have only translated the code into Python.
    """

    if p < PCRIT:
        x = acos(p/PCRIT)
        dv = (1 + x*(-1.8463850803362596 + x*(-1.1447872718878493 + x*(59.18702203076563 + x*(-403.5391431811611 + x*(1437.2007245332388+ x*(-3015.853540307519 + x*(3740.5790348670057 + x*(-2537.375817253895+ (725.8761975803782 - 0.0011151111658332337*x)*x)))))))))*DCRIT
    else:
        dv = DCRIT
    return dv


def _dofp13(p):
    """
    Density at the boundary between regions 1 and 3. This code is based
    on the Methodica implementation of water thermodynamics in C. I have only translated the code into Python.
    """

    p2 = 7.1 - 6.04960677555959e-8*p
    o = numpy.zeros(3)
    o[0] = p2*p2
    o[1] = o[0]*o[0]
    o[2] = o[1]*o[1]

    d = 57.4756752485113/(0.0737412153522555 + p2*(0.00145092247736023 +p2*(0.000102697173772229 + p2*(0.0000114683182476084 + p2*(1.99080616601101e-6 + o[0]*p2*(1.13217858826367e-8 + o[1]*o[2]*p2*(1.35549330686006e-17 + o[0]*(-3.11228834832975e-19 + o[0]*o[1]*(-7.02987180039442e-22+ p2*(3.29199117056433e-22 + (-5.17859076694812e-23 +2.73712834080283e-24*p2)*p2))))))))))
    return d


def _dofp23(p):
    """
    Density at the boundary between regions 2 and 3. This code is based
    on the Methodica implementation of water thermodynamics in C. I have only translated the code into Python.
    """

    pi = p/PSTAR2
    T = 572.54459862746 + 31.3220101646784 * numpy.sqrt(-13.91883977887 + pi)
    o = numpy.zeros(13)
    o[0]= numpy.sqrt(-13.91883977887 + pi)
    taug = -0.5 + 540.0 / (572.54459862746 + 31.3220101646784 * o[0])
    o[1]= taug * taug
    o[2]= o[1] * taug
    o[3]= o[1] * o[1]
    o[4]= o[3] * o[3]
    o[5]= o[4] * o[4]
    o[6]= o[3] * o[4] * o[5] * taug
    o[7]= o[3] * o[4] * taug
    o[8]= o[1] * o[3] * o[4]
    o[9]= pi * pi
    o[10]= o[9] * o[9]
    o[11]= o[3] * o[5] * taug
    o[12]= o[5] * o[5]

    gpi23 = (1.0 + pi*(-0.0017731742473213 + taug*(-0.017834862292358 +taug*(-0.045996013696365 + (-0.057581259083432 - 0.05032527872793*o[2])*taug)) + pi*(taug*(-0.000066065283340406 + (-0.0003789797503263 + o[1]*(-0.007878555448671 + o[2]*(-0.087594591301146 -0.000053349095828174*o[6])))*taug) + pi*(6.1445213076927e-8 + (1.31612001853305e-6 + o[1]*(-0.00009683303171571 + o[2]*(-0.0045101773626444- 0.122004760687947*o[6])))*taug + pi*(taug*(-3.15389238237468e-9 +(5.116287140914e-8 + 1.92901490874028e-6*taug)*taug) + pi*(0.0000114610381688305*o[1]*o[3]*taug + pi*(o[2]*(-1.00288598706366e-10+ o[7]*(-0.012702883392813 - 143.374451604624*o[1]*o[5]*taug)) + pi*(-4.1341695026989e-17 + o[1]*o[4]*(-8.8352662293707e-6 -0.272627897050173*o[8])*taug + pi*(o[4]*(9.0049690883672e-11 -65.8490727183984*o[3]*o[4]*o[5]) + pi*(1.78287415218792e-7*o[7] + pi*(o[3]*(1.0406965210174e-18 + o[1]*(-1.0234747095929e-12 -1.0018179379511e-8*o[3])*o[3]) + o[9]*o[10]*((-1.29412653835176e-9+ 1.71088510070544*o[11])*o[6] + o[9]*(-6.05920510335078*o[12]*o[4]*o[5]*taug + o[9]*(o[3]*o[5]*(1.78371690710842e-23 + o[1]*o[3]*o[4]*(6.1258633752464e-12 - 0.000084004935396416*o[7])*taug) + pi*(-1.24017662339842e-24*o[11] + pi*(0.0000832192847496054*o[12]*o[3]*o[5]*taug + pi*(o[1]*o[4]*o[5]*(1.75410265428146e-27 + (1.32995316841867e-15 -0.0000226487297378904*o[1]*o[5])*o[8])*pi - 2.93678005497663e-14*o[12]*o[1]*o[3]*taug)))))))))))))))))/pi
    d = p/(RH2O*T*pi*gpi23)

    return d


def _hlowerofp1(p):
    """
    Explicit lower specific enthalpy limit of region 1 as function of pressure. This code is based
    on the Methodica implementation of water thermodynamics in C. I have only translated the code into Python.
    """

    pi1 = 7.1 - p / PSTAR1
    o = numpy.zeros(3)
    o[0] = pi1 ** 2
    o[1] = o[0] ** 2
    o[2] = o[1] ** 2

    h = 639675.036*(0.173379420894777 + pi1*(-0.022914084306349 + pi1*(-0.00017146768241932 + pi1*(-4.18695814670391e-6 + pi1*(-2.41630417490008e-7 + pi1*(1.73545618580828e-11 + o[0]*pi1*(8.43755552264362e-14 + o[1]*o[2]*pi1 *(5.35429206228374e-35 + o[0]*(-8.12140581014818e-38 + o[0]*o[1]*(-1.43870236842915e-44 + pi1*(1.73894459122923e-45 + (-7.06381628462585e-47 + 9.64504638626269e-49*pi1)*pi1)))))))))))
    return h


def _hupperofp1(p):
    """
    Explicit upper specific enthalpy limit of region 1 as function of pressure (meets region 4 saturation pressure
    curve at 623.15 K). This code is based
    on the Methodica implementation of water thermodynamics in C. I have only translated the code into Python.
    """

    pi1 = 7.1 - p / PSTAR1
    o = numpy.zeros(3)
    o[0] = pi1 ** 2
    o[1] = o[0] ** 2
    o[2] = o[1] ** 2

    h = 639675.036*(2.42896927729349 + pi1*(-0.00141131225285294 + pi1*(0.00143759406818289 + pi1*(0.000125338925082983 + pi1*(0.0000123617764767172 + pi1*(3.17834967400818e-6 + o[0]*pi1*(1.46754947271665e-8 + o[1]*o[2]*pi1*(1.86779322717506e-17 + o[0]*(-4.18568363667416e-19 + o[0]*o[1]*(-9.19148577641497e-22 + pi1*(4.27026404402408e-22 + (-6.66749357417962e-23 + 3.49930466305574e-24*pi1)*pi1)))))))))))
    return h


def hlowerofp2(p):
    """
    Explicit lower specific enthalpy limit of region 2 as function of pressure (meets region 4 saturation pressure
    curve at 623.15 K). This code is based
    on the Methodica implementation of water thermodynamics in C. I have only translated the code into Python.
    """

    pi = p / PSTAR2
    q1 = 572.54459862746 + 31.3220101646784*(-13.91883977887 + pi) ** 0.5
    q2 = -0.5 + 540./q1
    o = numpy.zeros(18)
    o[0]= q1 * q1
    o[1]= o[0] * o[0]
    o[2]= o[1] * o[1]
    o[3]= pi * pi
    o[4]= o[3] * o[3]
    o[5]= q2 * q2
    o[6]= o[5] * o[5]
    o[7]= o[5] * o[6]
    o[8]= o[4] * o[4]
    o[9]= o[6] * o[6]
    o[10]= o[8] * o[8]
    o[11]= o[9] * o[9]
    o[12]= o[11] * o[11]
    o[13]= o[6] * q2
    o[14]= o[5] * q2
    o[15]= o[9] * o[5]
    o[16]= o[12] * o[5]
    o[17]= o[12] * o[5] * q2

    h = (4.63697573303507e9 + 3.74686560065793*o[1] + 3.57966647812489e-6*o[0]*o[1] + 2.81881548488163e-13*o[2] - 7.64652332452145e7*q1 -0.00450789338787835*o[1]*q1 - 1.55131504410292e-9*o[0]*o[1]*q1 + o[0]*(2.51383707870341e6 - 4.78198198764471e6*o[9]*o[10]*o[11]*o[12]*o[3]+ 49.9651389369988*o[10]*o[11]*o[12]*o[3]*o[4]*o[6] + o[14]*o[3]*(1.03746636552761e-13 - 0.00349547959376899*o[15] - 2.55074501962569e-7*o[7])*o[8] + (-242662.235426958*o[9]*o[11] - 3.46022402653609*o[15])*o[3]*o[4]*pi + o[3]*(0.109336249381227 -2248.08924686956*o[13] - 354742.725841972*o[16] - 24.1331193696374*o[5])*pi - 3.09081828396912e-19*o[10]*o[11]*o[4]*o[6]*pi -1.24107527851371e-8*o[10]*o[12]*o[3]*o[4]*o[5]*o[6]*pi + 3.99891272904219*o[4]*o[7]*pi + 0.0641817365250892*o[9]*o[6]*o[8]*pi+ pi*(-4444.87643334512 - 75253.6156722047*o[13] - 43051.9020511789*o[5] - 22926.6247146068*q2) + o[3]*(-8.23252840892034 -3927.0508365636*o[14] - 239.325789467604*o[17] - 76407.3727417716*o[7] - 94.4508644545118*q2) + 0.360567666582363*o[4]*(-0.0161221195808321 + q2)*(0.0338039844460968 + q2) + o[10]*(-0.000584580992538624*o[9]*o[11]*o[6] + 1.33248030241755e6*o[11]*o[12]*q2) + o[8]*(-7.38502736990986e7*o[17] + 0.0000224425477627799*o[5]*o[6]*q2) + o[3]*o[4]*(-2.08438767026518e8*o[16] - 0.0000124971648677697*o[5] - 8442.30378348203*o[9]*o[5]*o[6]*q2) + o[10]*o[8]*(4.73594929247646e-22*o[9]*o[11]*q2 -13.6411358215175*o[9]*o[11]*o[12]*q2 + 5.52427169406836e-10*o[12]*o[5]*o[6]*q2) + o[10]*o[4]*(2.67174673301715e-6*o[16] +4.44545133805865e-18*o[11]*o[5]*q2 - 50.2465185106411*o[9]*o[12]*o[5]*o[6]*q2)))/o[0]
    return h


def _hupperofp2(p):
    """
    Explicit upper specific enthalpy limit of region 2 as function of pressure. This code is based
    on the Methodica implementation of water thermodynamics in C. I have only translated the code into Python.
    """

    pi = p / PSTAR2
    o = numpy.zeros(2)
    o[0] = pi ** 2
    o[1] = o[0] ** 3

    h = 4.16066337647071e6 + pi*(-4518.48617188327 + pi*(-8.53409968320258 + pi*(0.109090430596056 + pi*(-0.000172486052272327 + pi*(4.2261295097284e-15 + pi*(-1.27295130636232e-10 + pi*(-3.79407294691742e-25 + pi*(7.56960433802525e-23 + pi*(7.16825117265975e-32 + pi*(3.37267475986401e-21 + (-7.5656940729795e-74 + o[0]*(-8.00969737237617e-134 + (1.6746290980312e-65 + pi*(-3.71600586812966e-69 + pi*(8.06630589170884e-129 + (-1.76117969553159e-103 + 1.88543121025106e-84*pi)*pi)))*o[0]))*o[1]))))))))))
    return h


def hlowerofp5(p):
    """
    Explicit lower specific enthalpy limit of region 5 as function of pressure. This code is based
    on the Methodica implementation of water thermodynamics in C. I have only translated the code into Python.
    """

    pi = p / PSTAR5
    return 461526.*(9.01505286876203 + pi*(-0.00979043490246092 + (-0.0000203245575263501 + 3.36540214679088e-7*pi)*pi))


def _hupperofp5(p):
    """
    Explicit upper specific enthalpy limit of region 5 as function of pressure. This code is based
    on the Methodica implementation of water thermodynamics in C. I have only translated the code into Python.
    """

    pi = p / PSTAR5
    return 461526.*(15.9838891400332 + pi*(-0.000489898813722568 + (-5.01510211858761e-8 + 7.5006972718273e-8*pi)*pi))


def _b23t(p):
    """
    Returns the temperature on the boundary between regions 2 and 3,given a pressure p (Pa).This code is based
    on the Methodica implementation of water thermodynamics in C. I have only translated the code into Python.
    """

    return nr23[3] + numpy.sqrt((p / 1.e6 - nr23[4]) / nr23[2])


def _sat(t):
    """
    saturation pressure as a function of temperature. This was written by Adrian Croucher, in the IAPWS implementation
    of PyTOUGH.
    """

    if 0. <= t <= TCRIT:

        tk = t
        theta = tk + nr4[8] / (tk - nr4[9])
        theta2 = theta * theta
        a = theta2 + nr4[0] * theta + nr4[1]
        b = nr4[2] * theta2 + nr4[3] * theta + nr4[4]
        c = nr4[5] * theta2 + nr4[6] * theta + nr4[7]
        x = 2. * c / (-b + numpy.sqrt(b * b - 4. * a * c))
        x = x * x
        p = PSTAR4 * x * x
        return p

    else: return None


def _t_sat(p):
    """
    _saturation temperature (deg K) as a function of pressure.  Returns
    false if called outside its operating range (611.213 Pa <= p <=
    critical pressure). This was written by Adrian Croucher, in the IAPWS implementation
    of PyTOUGH.
    """

    if 611.213 <= p <= PCRIT:

        beta2 = numpy.sqrt(p / PSTAR4)
        beta = numpy.sqrt(beta2)
        e = beta2 + nr4[2] * beta + nr4[5]
        f = nr4[0] * beta2 + nr4[3] * beta + nr4[6]
        g = nr4[1] * beta2 + nr4[4] * beta + nr4[7]
        d = 2.0 * g / (-f - numpy.sqrt(f * f - 4. * e * g))
        x = nr4[9] + d
        t = 0.5 * (nr4[9] + d - numpy.sqrt(x * x - 4. * (nr4[8] + nr4[9] * d)))
        return t

    else: return None


def _tsat_diff(p):

    if p >= 611.213 and p <= PCRIT:

        beta2 = numpy.sqrt(p / PSTAR4)
        beta = numpy.sqrt(beta2)
        e = beta2 + nr4[2] * beta + nr4[5]
        f = nr4[0] * beta2 + nr4[3] * beta + nr4[6]
        g = nr4[1] * beta2 + nr4[4] * beta + nr4[7]
        d = 2.0 * g / (-f - numpy.sqrt(f * f - 4. * e * g))
        x = nr4[9] + d

        dedbeta = 2. * beta + nr4[2]
        dfdbeta = 2. * nr4[0] * beta + nr4[3]
        dgdbeta = 2. * nr4[1] * beta + nr4[4]

        dbotdbeta = -1. * dfdbeta - (f * dfdbeta - 2. * (e * dgdbeta + g * dedbeta)) / numpy.sqrt(f * f - 4. * e * g)
        dD_d_beta = (2. * dgdbeta * (-f - numpy.sqrt(f * f - 4. * e * g)) - dbotdbeta * 2. * g) / (
                    -f - numpy.sqrt(f * f - 4. * e * g)) ** 2
        dt_dD = 0.5 * (1. - (-1. * nr4[9] + d) / (numpy.sqrt(x * x - 4. * (nr4[8] + nr4[9] * d))))
        dt_d_beta = dD_d_beta * dt_dD

        return dt_d_beta * beta / (4. * p)
    else: return None


def _hofpT1(p, T):
    """
    Intermediate function for isentropic specific enthalpy in region 1.This code is based
    on the Methodica implementation of water thermodynamics in C. I have only translated the code into Python.
    """

    tau = TSTAR1 / T
    pi1 = 7.1 - p / PSTAR1
    tau1 = -1.222 + tau
    o = numpy.zeros(13)

    o[0]= tau1 * tau1
    o[1]= o[0] * tau1
    o[2]= o[0] * o[0]
    o[3]= o[2] * o[2]
    o[4]= o[0] * o[3]
    o[5]= o[0] * o[2]
    o[6]= o[2] * tau1
    o[7]= o[2] * o[3]
    o[8]= pi1 * pi1
    o[9]= o[8] * o[8]
    o[10]= o[9] * o[9]
    o[11]= o[3] * o[3]
    o[12]= o[11] * o[11]

    h = RH2O*T*tau*(pi1*((-0.00254871721114236 + o[0]*(0.00424944110961118 + (0.018990068218419 + (-0.021841717175414 -0.00015851507390979*o[0])*o[0])*o[5]))/o[4] + pi1*((0.00141552963219801 + o[2]*(0.000047661393906987 + o[0]*(-0.0000132425535992538 - 1.2358149370591e-14*o[0]*o[2]*o[3])))/o[2] + pi1*((0.000126718579380216 - 5.11230768720618e-9*o[4])/o[6] + pi1*((0.000011212640954 + o[1]*(1.30342445791202e-6 - 1.4341729937924e-12*o[7]))/o[5] + pi1*(o[8]*pi1*((1.40077319158051e-8 + 1.04549227383804e-9*o[5])/o[7] + o[9]*o[10]*pi1*(1.9941018075704e-17/(o[0]*o[11]*o[2]*o[3]) + o[8]*(-4.48827542684151e-19/o[12] + o[9]*o[8]*(pi1*(4.65957282962769e-22/(o[12]*o[3]) + pi1*((3.83502057899078e-24*pi1)/(o[0]*o[12]*o[3]) - 7.2912378325616e-23/(o[12]*o[3]*tau1))) -1.00075970318621e-21/(o[0]*o[12]*o[2]*tau1))))) + 3.24135974880936e-6/(o[3]*tau1)))))) + (-0.29265942426334 + tau1*(0.84548187169114 + o[0]*(3.3855169168385 + tau1*(-1.91583926775744 + tau1*(0.47316115539684+ (-0.066465668798004 + 0.0040607314991784*tau1)*tau1)))))/o[1])
    return h


def _hofpT2(p, T):
    """
    Intermediate function for isentropic specific enthalpy in region 2. This code is based
    on the Methodica implementation of water thermodynamics in C. I have only translated the code into Python.
    """

    pi = p / PSTAR2
    tau = TSTAR2 / T
    tau2 = -0.5 + tau
    o = numpy.zeros(16)

    o[0]= tau * tau
    o[1]= o[0] * o[0]
    o[2]= tau2 * tau2
    o[3]= o[2] * tau2
    o[4]= o[2] * o[2]
    o[5]= o[4] * o[4]
    o[6]= o[5] * o[5]
    o[7]= o[4] * o[5] * o[6] * tau2
    o[8]= o[2] * o[4]
    o[9]= o[4] * o[5] * tau2
    o[10]= o[2] * o[6] * tau2
    o[11]= o[2] * o[4] * o[5]
    o[12]= o[4] * o[5] * o[6]
    o[13]= pi * pi
    o[14]= o[13] * o[13]
    o[15]= o[6] * o[6]

    h = RH2O*T*tau*((0.0280439559151 + tau*(-0.2858109552582 + tau*(1.2213149471784 + tau*(-2.848163942888 + tau*(4.38395111945 + o[0]*(10.08665568018 + (-0.5681726521544 + 0.06380539059921*tau)*tau))))))/(o[0]*o[1]) + pi*(-0.017834862292358 + tau2*(-0.09199202739273 + (-0.172743777250296- 0.30195167236758*o[3])*tau2) + pi*(-0.000033032641670203 + (-0.0003789797503263 + o[2]*(-0.015757110897342 + o[3]*(-0.306581069554011 -0.000960283724907132*o[7])))*tau2 + pi*(4.3870667284435e-7 + o[2]*(-0.00009683303171571 + o[3]*(-0.0090203547252888 - 1.42338887469272*o[7])) + pi*(-7.8847309559367e-10 + (2.558143570457e-8 + 1.44676118155521e-6*tau2)*tau2 + pi*(0.0000160454534363627*o[8] + pi*((-5.0144299353183e-11 + o[9]*(-0.033874355714168 - 836.35096769364*o[10]))*o[2] + pi*((-0.0000138839897890111 -0.973671060893475*o[11])*o[2]*o[5] + pi*((9.0049690883672e-11 -296.320827232793*o[12])*o[2]*o[4]*tau2 + pi*(2.57526266427144e-7*o[4]*o[5] + pi*(o[3]*(4.1627860840696e-19 + (-1.0234747095929e-12 -1.40254511313154e-8*o[4])*o[8]) + o[13]*o[14]*(o[12]*(-2.34560435076256e-9 + 5.3465159397045*o[4]*o[6]*tau2) + o[13]*(-19.1874828272775*o[15]*o[5]*o[6] + o[13]*(o[10]*(1.78371690710842e-23 + (1.07202609066812e-11 - 0.000201611844951398*o[9])*o[2]*o[4]*o[5]*tau2) + pi*(-1.24017662339842e-24*o[4]*o[6] + pi*(0.000200482822351322*o[15]*o[4]*o[6] + pi*(-4.97975748452559e-14*o[15]*o[2]*o[4] + o[5]*o[6]*(1.90027787547159e-27 + o[11]*(2.21658861403112e-15 - 0.0000547344301999018*o[2]*o[6]))*pi*tau2)))))))))))))))))
    return h


def _hl_p(p):
    """
    Boiling curve. Yield the enthalpy of the liquid phase for a given pressure. This code is based
    on the Methodica implementation of water thermodynamics in C. I have only translated the code into Python.
    """
    plim = min(p, PCRIT - 1e-7)
    T = _t_sat(plim)
    region3boundary = T > TLIMIT1
    if not region3boundary:
        _, gtau, tau = _g1(p, T)
        if p > plim:
            return HCRIT
        else:
            return RH2O * TSTAR1 * gtau
            # return RH2O * T * tau * gtau
    else:
        return _hl_p_R4b(plim)


def _hl_p_diff(p):
    """
    Boiling curve. Yield the enthalpy of the liquid phase for a given pressure. This code is based
    on the Methodica implementation of water thermodynamics in C. I have only translated the code into Python.
    """
    plim = min(p, PCRIT - 1e-7)
    T = _t_sat(plim)
    dTdP = _tsat_diff(plim)
    region3boundary = T > TLIMIT1
    if not region3boundary:
        gtautau, gtau, tau = _g1(p, T)
        if p > plim:
            return 0.
        else:
            return RH2O * dTdP * (-(TSTAR1/T)**2) * gtautau
            # return RH2O * T * tau * gtau
    else:
        return _hl_p_R4b_diff(plim)


def _hv_p(p):
    """
    Dew curve. Yield the enthalpy of the vapour phase for a given pressure. This code is based
    on the Methodica implementation of water thermodynamics in C. I have only translated the code into Python.
    """

    plim = min(p, PCRIT - 1e-7)
    T = _t_sat(plim)
    region3boundary = T > TLIMIT1
    if not region3boundary:
        _, gtau, tau = _g2(p, T)
        if p > plim:
            return HCRIT
        else:
            return RH2O * TSTAR2 * gtau
            # return RH2O * T * tau * gtau
    else:
        return _hv_p_R4b(plim)


def _hv_p_diff(p):
    """
    Boiling curve. Yield the enthalpy of the liquid phase for a given pressure. This code is based
    on the Methodica implementation of water thermodynamics in C. I have only translated the code into Python.
    """
    plim = min(p, PCRIT - 1e-7)
    T = _t_sat(plim)
    dTdP = _tsat_diff(plim)
    region3boundary = T > TLIMIT1
    if not region3boundary:
        gtautau, gtau, tau = _g2(p, T)
        if p > plim:
            return 0.
        else:
            return RH2O * dTdP * (-(TSTAR2/T)**2) * gtautau
            # return RH2O * T * tau * gtau
    else:
        return _hl_p_R4b_diff(plim)


def _hl_p_R4b(p):
    """
    Expression of the enthalpy on the boiling curve between region 3 and 4 with respect to the pressure.This code is based
    on the Methodica implementation of water thermodynamics in C. I have only translated the code into Python.
    """

    x = acos(p / PCRIT)
    h = (1 + x * (-0.4945586958175176 + x * (1.346800016564904 + x * (-3.889388153209752 + x * (
                6.679385472887931 + x * (-6.75820241066552 + x * (
                    3.558919744656498 + (-0.7179818554978939 - 0.0001152032945617821 * x) * x))))))) * HCRIT
    return h


def _hl_p_R4b_diff(p):
    """
    Expression of the enthalpy on the boiling curve between region 3 and 4 with respect to the pressure.This code is based
    on the Methodica implementation of water thermodynamics in C. I have only translated the code into Python.
    """

    x = - 1 * (1 - (p / PCRIT) ** 2)
    h = (-0.4945586958175176 + 2*x * (1.346800016564904 + 1.5*x * (-3.889388153209752 + (4 * x/3) * (
                6.679385472887931 + (5 * x / 4) * (-6.75820241066552 + (6 * x / 5) * (
                    3.558919744656498 + (-0.7179818554978939 - 0.0001152032945617821 * (8 * x / 7)) * (7 *x /6))))))) * HCRIT
    return h


def _hv_p_R4b(p):
    """Explicit approximation of vapour specific enthalpy on the boundary between regions 4 and 3"""

    x = acos(p / PCRIT)
    h = (1 + x*(0.4880153718655694 + x*(0.2079670746250689 + x*(-6.084122698421623+ x*(25.08887602293532 + x*(-48.38215180269516 + x*(45.66489164833212 + (-16.98555442961553 + 0.0006616936460057691*x)*x)))))))*HCRIT

    return h


def _hv_p_R4b_diff(p):
    """
    Expression of the enthalpy on the dew curve between region 3 and 4 with respect to the pressure.This code is based
    on the Methodica implementation of water thermodynamics in C. I have only translated the code into Python.
    """

    x = - 1 * (1 - (p / PCRIT) ** 2)
    h = (0.4880153718655694 + 2 * x * (0.2079670746250689 + 1.5 * x * (-6.084122698421623 + (4 * x/3) * (
                25.08887602293532 + (5 * x / 4) * (-48.38215180269516 + (6 * x / 5) * (
                    45.66489164833212 + (-16.98555442961553 + 0.0006616936460057691 * (8 * x / 7)) *(7 *x /6))))))) * HCRIT
    return h


def _region_ph(p, h, phase= 0, mode= 0):
    """
    Yield corresponding thermodynamic region to given (p, h).This code is based
    on the Methodica implementation of water thermodynamics in C. I have only translated the code into Python.
    """

    if mode != 0:
        return mode
    else:
        hl = _hl_p(p)
        hv = _hv_p(p)

        if phase == 2: return 4
        else:
            if p < ptriple or p > PLIMIT1 or h < _hlowerofp1(p) or (p < 10e6 and h > _hupperofp5(p)) or (p >= 10e6 and h > _hupperofp2(p)): return -1
            else:
                hsubcrit = h < HCRIT
                if p < PLIMIT4A:
                    if hsubcrit:
                        if phase == 1: return 1
                        else:
                            if h < _hofpT1(p, _t_sat(p)): return 1
                            else: return 4
                    else:
                        if h > hlowerofp5(p):
                            if p < PLIMIT5 and h < _hupperofp5(p): return 5
                            else: return 2
                        else:
                            if phase == 1: return 2
                            else:
                                if h > _hofpT2(p, _t_sat(p)): return 2
                                else: return 4
                else:
                    if hsubcrit:
                        if h < _hupperofp1(p): return 1
                        else:
                            if h < hl or p > PCRIT: return 3
                            else: return 4
                    else:
                        if h > hlowerofp2(p): return 2
                        else:
                            if h > hv or p > PCRIT: return 3
                            else: return 4


def _region_pT(p, T, mode= 0):
    """
    Yield corresponding thermodynamic region to given (p, T). This code is based
    on the Methodica implementation of water thermodynamics in C. I have only translated the code into Python.
    """

    if mode != 0:
        return mode
    else:
        if p < PLIMIT4A:
            if T > TLIMIT2:
                region = 5
            elif T > _t_sat(p):
                region = 2
            else:
                region = 1
        else:
            if T <= TLIMIT1:
                region = 1
            elif T < _b23t(p):
                region = 3
            else:
                region = 2
    return region


# ----------------------------------------------------------------------------------------------------------------------
# SPLINES EVAlUATION TOOLS

def _evaluate_derivatives(props, h, P, dh, dP):
    """
    Evaluate de desired partial derivatives of the properties of interest for the given values of enthalpy and pressure.
    If a desired point is outside of the thermodynamic domain, it won't return an error but the value of the desired
    properties will be set to NaN.
    :param props: List of the desired properties
    :param h: List of the given enthalpy
    :param P: List of the given pressures
    :param dh: List of the given derivative orders with respect to enthalpy
    :param dP: List of the given derivative orders with respect to pressure
    :return: Matrix of results of shape (len(h) * (len(props) + 4)), for each observation the order of the data is the
            following [h, P, dh, dP, prop_1,..., prop_n] for single phase. For 2-phase fluid, the observation also
            include the properties related to each phases in the following form:
                [h, P, prop_1,..., prop_n, [h_v, prop_1_v, ..., prop_n_v], [h_l, prop_1_l, ..., prop_n_l]]
            where, the first members are the same as in 1 phase, but then the output contains to additional lists, the
            first one relates to the vapour phase and the second one to the liquid phase.
    """
    output = []
    for j in range(len(dh)):
        for i in range(len(h)):
            tmp = [h[i], P[i], dh[j], dP[j]]
            if dh[j] != 0 and dP[j] != 0:
                factor = (dh[j] * scaling['h']) * (dP[j] * scaling['P'])
            else:
                if dh[j] != 0: factor = (dh[j] * scaling['h'])
                else: factor = (dP[j] * scaling['P'])
            if 611.23 <= P[i] <= 100e6 and 1000. <= h[i] <= 4500e3:
                region = _region_ph(P[i], h[i])
                if region in [1,2,3,5]:
                    for prop in props:
                        if prop != 's':
                            tmp.append(_derr_eval(spl_objs[prop], h[i] * scaling['h'], P[i] * scaling['P'], dh[j], dP[j]) * factor / scaling[prop]) # * factor / scaling[prop]
                        else:
                            if region == 1:
                                tmp.append(0)
                            elif region == 2:
                                tmp.append(1)
                            elif region == 3:
                                tmp.append(-1)
                # elif region == 4:
                #     # For 2 phase only the first order derivatives and supported
                #     if dh[j] + dP[j] == 1:
                #         hl, hv = _hl_p(P[i]), _hv_p(P[i])
                #         # Derivative of phase enthalpy wrt P
                #         if hl == hv: x = 1.
                #         else: x = (h[i] - hl) / (hv - hl)
                #
                #         Tl, Tv = _eval(spl_objs['T'], hl*scaling['h'], P[i]*scaling['P']) / scaling['T'], _eval(spl_objs['T'], hv*scaling['h'], P[i]*scaling['P']) / scaling['T']
                #         dl, dv = _eval(spl_objs['d'], hl * scaling['h'], P[i] * scaling['P']) / scaling['d'], _eval(spl_objs['d'], hv * scaling['h'], P[i] *scaling['P']) / scaling['d']
                #         T = Tl + x * (Tv - Tl)
                #         d = dl * dv / (dv + x * (dl - dv))
                #         v = 1./_visc(d, T)
                #         if dh[j] == 1:
                #             delh = h[i] + delt
                #             if hl == hv: delx = 1.
                #             else: delx = (delh - hl) / (hv - hl)
                #
                #             Tl, Tv = _eval(spl_objs['T'], hl * scaling['h'], P[i] * scaling['P']) / scaling['T'], _eval(
                #                 spl_objs['T'], hv * scaling['h'], P[i] * scaling['P']) / scaling['T']
                #             dl, dv = _eval(spl_objs['d'], hl * scaling['h'], P[i] * scaling['P']) / scaling['d'], _eval(
                #                 spl_objs['d'], hv * scaling['h'], P[i] * scaling['P']) / scaling['d']
                #             delT = Tl + delx * (Tv - Tl)
                #             deld = dl * dv / (dv + delx * (dl - dv))
                #             delv = 1./_visc(deld, delT)
                #
                #         else:
                #             delp = P[i] + delt
                #             delhl, delhv = _hl_p(delp), _hv_p(delp)
                #             if hl == hv: delx = 1.
                #             else: delx = (h[i] - delhl) / (delhv - delhl)
                #
                #             Tl, Tv = _eval(spl_objs['T'], delhl * scaling['h'], delp * scaling['P']) / scaling['T'], _eval(
                #                 spl_objs['T'], delhv * scaling['h'], delp * scaling['P']) / scaling['T']
                #             dl, dv = _eval(spl_objs['d'], delhl * scaling['h'], delp * scaling['P']) / scaling['d'], _eval(
                #                 spl_objs['d'], delhv * scaling['h'], delp * scaling['P']) / scaling['d']
                #             delT = Tl + delx * (Tv - Tl)
                #             deld = dl * dv / (dv + delx * (dl - dv))
                #             delv = 1./_visc(deld, delT)
                #         dT = (delT - T) / delt
                #         dd = (deld - d) / delt
                #         dv = (delv - v) / delt
                #         for prop in props:
                #             if prop == 'T':
                #                 tmp.append(dT)
                #             elif prop == 'd':
                #                 tmp.append(dd)
                #             elif prop == 'v':
                #                 tmp.append(dv)
                #             else:
                #                 tmp.append(x)
                    else:
                        for prop in props:
                            tmp.append(numpy.nan)

                else:
                    for prop in props:
                        tmp.append(numpy.nan)
            else:
                for prop in props:
                    tmp.append(numpy.nan)
            output.append(tmp)
    return output


def _evaluate_values(props, h, P):
    """
    Evaluate de desired partial derivatives of the properties of interest for the given values of enthalpy and pressure.
    If a desired point is outside of the thermodynamic domain, it won't return an error but the value of the desired
    properties will be set to NaN.
    :param props: List of the desired properties
    :param h: List of the given enthalpy
    :param P: List of the given pressures
    :return: Matrix of results of shape (len(h) * (len(props) + 2)), for each observation the order of the data is the
            following [h, P, prop_1,..., prop_n] for single phase. For 2-phase fluid, the observation also include the
            properties related to each phases in the following form:
                [h, P, prop_1,..., prop_n, [h_v, prop_1_v, ..., prop_n_v], [h_l, prop_1_l, ..., prop_n_l]]
            where, the first members are the same as in 1 phase, but then the output contains to additional lists, the
            first one relates to the vapour phase and the second one to the liquid phase.
    """
    output = []
    for i in range(len(h)):
        tmp = [h[i], P[i]]
        if 611.23 <= P[i] <= 100e6 and 1000. <= h[i] <= 4500e3:
            region = _region_ph(P[i], h[i])
            if region in [1, 2, 3]:
                for prop in props:
                    if prop != 's':
                        tmp.append(_eval(spl_objs[prop], h[i]*scaling['h'], P[i]*scaling['P']) / scaling[prop])
                    else:
                        if region == 1:
                            tmp.append(0)
                        elif region == 2:
                            tmp.append(1)
                        elif region == 3:
                            tmp.append(-1)
            elif region == 4:
                hl, hv = _hl_p(P[i]), _hv_p(P[i])
                vtmp, ltmp = [hv], [hl]
                if hl == hv: x = 1.
                else: x = (h[i] - hl) / (hv - hl)
                Tl, Tv = _eval(spl_objs['T'], hl*scaling['h'], P[i]*scaling['P']) / scaling['T'], _eval(spl_objs['T'], hv*scaling['h'], P[i]*scaling['P']) / scaling['T']
                dl, dv = _eval(spl_objs['d'], hl * scaling['h'], P[i] * scaling['P']) / scaling['d'], _eval(spl_objs['d'], hv * scaling['h'], P[i] *scaling['P']) / scaling['d']
                vl, vv = _eval(spl_objs['v'], hl * scaling['h'], P[i] * scaling['P']) / scaling['v'], _eval(spl_objs['v'], hv * scaling['h'], P[i] *scaling['P']) / scaling['v']
                T = Tl + x * (Tv - Tl)
                d = dl * dv / (dv + x * (dl - dv))
                for prop in props:
                    if prop == 'T':
                        tmp.append(T)
                        ltmp.append(Tl)
                        vtmp.append(Tv)
                    elif prop == 'd':
                        tmp.append(d)
                        ltmp.append(dl)
                        vtmp.append(dv)
                    elif prop == 'v':
                        tmp.append(1./_visc(d,T))
                        ltmp.append(vl)
                        vtmp.append(vv)
                    else: tmp.append(x)
                tmp.append(vtmp)
                tmp.append(ltmp)
            else:
                for prop in props:
                    tmp.append(numpy.nan)
        else:
            for prop in props:
                tmp.append(numpy.nan)
        output.append(tmp)
    return output


def _eval(spl_obj, x, y):
    """
    Evaluate the bivariate spline approximation for a given enthalpy and pressure, at a given order (by default 3).
    :param spl_obj: Dict containing the list of coeficients, knots and the orders of the polynomial for the desired
            property.
    :param x: Float, Value of enthalpy
    :param y:  Float, Value of pressure
    :param lo: List (2,), An optional parameter which is used by the _derr_eval function in order to compute the spline
            at a lower order.
    :return: Float, value of the desired property
    """

    tx, ty, c = spl_obj['tx'], spl_obj['ty'], spl_obj['c']
    kx, ky = spl_obj['kx'], spl_obj['ky']
    z, ier = dfitpack.bispev(tx,ty,c,kx,ky,x,y)
    return z


def _derr_eval(spl_obj, x, y, dx, dy):
    """
    Evaluate the desired partial derivative of the spline approximation.
    :param spl_obj: Dict containing the list of coeficients, knots and the orders of the polynomial for the desired
            property.
    :param x: Float, Value of enthalpy.
    :param y: Float, Value of pressure.
    :param dx: Int, Order of the partial derivative with respect to h
    :param dy: Int, Order of the partial derivative with respect to P
    :return: Float, value of the desired partial derivative.
    """

    tx, ty, c = spl_obj['tx'], spl_obj['ty'], spl_obj['c']
    kx, ky = spl_obj['kx'], spl_obj['ky']
    z, ier = dfitpack.parder(tx, ty, c, kx,ky, dx,dy, x, y)
    return z


# ----------------------------------------------------------------------------------------------------------------------
# I/O

# INPUT HANDLING

def _format_xy(var, symb):
    """
    Formats the given data related to enthalpy and pressure. If unable to convert the data to the right format raises
    a value errors. Supported formats are int, float, list, ndarray.
    :param var: The data we wish to format.
    :param symb: The symbol associated to the data (P, h, T)
    :return: Float, list of floats, the formatted data
    """

    if isinstance(var, (list, numpy.ndarray)):
        if isinstance(var, numpy.ndarray):
            var = list(var)
        try:
            var = [float(v) for v in var]
        except ValueError: raise ValueError("Some of data from " + symb + " can't be converted to float")
    elif isinstance(var, int):
        var = float(var)
    elif not isinstance(var, float):
        raise ValueError("Type of " + symb + " is not supported. Supported type are float, integer, list or array")
    return var


def _format_der(var, symb):
    """
    Formats the given data related to enthalpy and pressure. If unable to convert the data to the right format raises
    a value errors. Supported formats are int, float, list, ndarray.
    :param var: The data we wish to format.
    :param symb: The symbol associated to the data (dh, dP)
    :return: Int, list of Int, the formatted data
    """

    if isinstance(var, (list, numpy.ndarray)):
        if isinstance(var, numpy.ndarray):
            var = list(var)
        try:
            var = [int(v) for v in var]
        except ValueError: raise ValueError("Some of data from " + symb + " can't be converted to int")
    elif isinstance(var, float):
        var = int(var)
    elif not isinstance(var, int):
        raise ValueError("Type of " + symb + " is not supported. Supported type are float, integer, list or array")
    return var


# ----------------------------------------------------------------------------------------------------------------------
# GENERAL PROPERTIES HANDLING FUNCTION

def properties(x, y, dx=None, dy=None, x_type="h", desired_props=None,write_file=False, path='', filename='props'):
    """
    General function the user can call to compute the thermodynamic properties of water. The user can give singular of
    set of values for each parameters (enthalpy, pressure, dh, dP) in different formats.
    The algorithm starts by formatting the input data. Then builds the tasks and call the evaluation functions.
    The algorithm then return a list of list to the user containing the values of the properties he desired.
    :param x: List, ndarray, float, int. Value(s) of enthalpy to be used (J.kg-1)
    :param y: List, ndarray, float, int. Value(s) of enthalpy to be used (Pa)
    :param dx: List, ndarray, float, int. Order(s) of the derivative wrt enthalpy to be used
    :param dy: List, ndarray, float, int. Order(s) of the derivative wrt pressure to be used
    :param x_type: Str, Optional, set to 'T' if giving values of temperature instead of total enthalpy. The algorithm
            will then automatically handle the conversion.
    :param desired_props: str, List of str, Optional (default= None). If None, all available properties are returned. If
            set the user can choose to only return certain properties, using the following keywords for example: ['density',
            'saturation', 'temperature', 'viscosity']
    :param write_file: Boolean, Optional, default=False, if set to True the algorithm will dump the output into a json
            file.
    :param path: Str, Optional, Used if write_file is True, path to the desired writing directory
    :param filename: Str, Optional, Name of the desired output file, don't include the extension.
    :return: List of list, general output data
    """

    ##### INPUT CHECK
    #Check if script is able to create output file
    if write_file:
        file = open(path+filename+'.json', 'w+')

    #Check type of input desired_props, change it to a list if possible
    if desired_props is None:
        desired_props = ["d", "T", "nu", "s"]
    else:
        if not isinstance(desired_props,list):
            if isinstance(desired_props,str):
                desired_props = [desired_props]
            elif isinstance(desired_props,numpy.ndarray):
                desired_props = list(desired_props)
            else:
                raise ValueError("The format the desired properties was given in is not supported. formats supported: string, list of strings or array of strings.")
    #Recognize the desired properties if possible
    for ip, prop in enumerate(desired_props):
        if prop in ['t', 'T', 'temp', 'temperature', 'Temperature']:
            desired_props[ip] = 'T'
        elif prop in ['d', 'D', 'density', 'Density']:
            desired_props[ip] = 'd'
        elif prop in ['v', 'V', 'nu', 'visc', 'viscosity', 'Viscosity']:
            desired_props[ip] = 'v'
        elif prop in ['s', 'S', 'sat', 'saturation', 'Saturation']:
            desired_props[ip] = 's'
        else:
            raise Exception("The property " + prop + " was not recognised. The supported formats are the following: 't', 'T', 'temp', 'temperature', 'Temperature' | 'd', 'D', 'density', 'Density' | 'v', 'V', 'nu', 'visc', 'viscosity', 'Viscosity' | 's', 'S', 'sat', 'saturation', 'Saturation'.")

    #Check vars
    x = _format_xy(x, "X")
    y = _format_xy(y, "Y")
    if dx is not None: dx = _format_der(dx, "dx")
    if dy is not None: dy = _format_der(dy, "dy")

    #Check x_type
    t = None
    if x_type not in  ['h', 'H', 'enthalpy', 'Enthalpy']:
        if x_type in ['t', 'T', 'temperature', 'Temperature']:
            if isinstance(x, list):
                t = x.copy()
                x = [_convert_T_to_h(y[i], x[i]) for i in range(len(x))]
            else:
                t = [x]
                x = _convert_T_to_h(y, x)
        else:
            raise Exception("Type of X variable was not recognised. If X is a temperature please use one of the following strings: 't', 'T', 'temperature', 'Temperature'.")
    #####

    #Build tasks
    if isinstance(x,float) and isinstance(y,float):
        x, y = [x], [y]
    elif isinstance(x,float) and isinstance(y,list):
        x = [x for i in range(len(y))]
    elif isinstance(y,float) and isinstance(x,list):
        y = [y for i in range(len(x))]
    elif isinstance(y,list) and isinstance(x,list):
        if len(x) == 1: x = [x[0] for i in range(len(y))]
        elif len(y) == 1: y = [y[0] for i in range(len(x))]
        elif len(x) != len(y):
            raise Exception("Lenghts of X and Y arrays don't match. The script will compute the properties in the following cases. Case 1: Both X and Y are variables; In that case two arrays/lists of the same sizes must be given. Case 2: One of the parameters is constant; In that case the constant parameter can be given either as a float, integer or array/list of size 1.")

    if isinstance(dx,int) and isinstance(dy,int):
        dx, dy = [dx], [dy]
    elif isinstance(dx,int) and isinstance(dy,list):
        dx = [dx for i in range(len(dy))]
    elif isinstance(dy,int) and isinstance(dx,list):
        dy = [dy for i in range(len(dx))]
    elif dx is None and isinstance(dy,int):
        dx, dy = [0], [dy]
    elif dy is None and isinstance(dx,int):
        dx, dy = [dx], [0]
    elif dx is None and isinstance(dy,list):
        dx = [0 for i in range(len(dy))]
    elif dy is None and isinstance(dx,list):
        dy = [0 for i in range(len(dx))]


    # Calls the necessary property _evaluation scripts
    if dx is not None and dy is not None:
        output = _evaluate_derivatives(desired_props, x, y, dx, dy)
    else:
        output = _evaluate_values(desired_props, x, y)

    # Write into output file
    if write_file:
        json.dump(output, file)
    return output


def density(x, y, dx=None, dy=None, x_type='h'):
    """
    Wrapper of the function properties for computing only the density of water.
    :param x: List, ndarray, float, int. Value(s) of enthalpy to be used (J.kg-1)
    :param y: List, ndarray, float, int. Value(s) of enthalpy to be used (Pa)
    :param dx: List, ndarray, float, int. Order(s) of the derivative wrt enthalpy to be used
    :param dy: List, ndarray, float, int. Order(s) of the derivative wrt pressure to be used
    :param x_type: Str, Optional, set to 'T' if giving values of temperature instead of total enthalpy. The algorithm
            will then automatically handle the conversion.
    :return: List of list, density related output data
    """
    return properties(x, y,dx=dx, dy=dy, x_type=x_type, desired_props=['d'])


def temperature(x, y, dx=None, dy=None, x_type='h'):
    """
    Wrapper of the function properties for computing only the temperature of water.
    :param x: List, ndarray, float, int. Value(s) of enthalpy to be used (J.kg-1)
    :param y: List, ndarray, float, int. Value(s) of enthalpy to be used (Pa)
    :param dx: List, ndarray, float, int. Order(s) of the derivative wrt enthalpy to be used
    :param dy: List, ndarray, float, int. Order(s) of the derivative wrt pressure to be used
    :param x_type: Str, Optional, set to 'T' if giving values of temperature instead of total enthalpy. The algorithm
            will then automatically handle the conversion.
    :return: List of list, temperature related output data
    """
    return properties(x, y,dx=dx, dy=dy, x_type=x_type, desired_props=['T'])


def viscosity(x, y, dx=None, dy=None, x_type='h'):
    """
    Wrapper of the function properties for computing only the viscosity of water.
    :param x: List, ndarray, float, int. Value(s) of enthalpy to be used (J.kg-1)
    :param y: List, ndarray, float, int. Value(s) of enthalpy to be used (Pa)
    :param dx: List, ndarray, float, int. Order(s) of the derivative wrt enthalpy to be used
    :param dy: List, ndarray, float, int. Order(s) of the derivative wrt pressure to be used
    :param x_type: Str, Optional, set to 'T' if giving values of temperature instead of total enthalpy. The algorithm
            will then automatically handle the conversion.
    :return: List of list, viscosity related output data
    """
    return properties(x, y,dx=dx, dy=dy, x_type=x_type, desired_props=['v'])


def saturation(x, y, dx=None, dy=None, x_type='h'):
    """
    Wrapper of the function properties for computing only the phase saturation.
    :param x: List, ndarray, float, int. Value(s) of enthalpy to be used (J.kg-1)
    :param y: List, ndarray, float, int. Value(s) of enthalpy to be used (Pa)
    :param dx: List, ndarray, float, int. Order(s) of the derivative wrt enthalpy to be used
    :param dy: List, ndarray, float, int. Order(s) of the derivative wrt pressure to be used
    :param x_type: Str, Optional, set to 'T' if giving values of temperature instead of total enthalpy. The algorithm
            will then automatically handle the conversion.
    :return: List of list, saturation related output data
    """
    return properties(x, y,dx=dx, dy=dy, x_type=x_type, desired_props=['s'])

# ----------------------------------------------------------------------------------------------------------------------
# PATH_CLOUDS = '/home/lmar626/Documents/SuperCritical/SuperCritical/Clouds/ph/'
#
hd, Pd = numpy.meshgrid(numpy.linspace(HMIN,HMAX,500), numpy.linspace(PMIN,PMAX,500))
hf, Pf = hd.flatten(), Pd.flatten()
dh = properties(hf, Pf, dx=1)
dp = properties(hf, Pf, dy=1)
# # data = numpy.zeros((len(props),5))
# # for ip in range(len(props)):
# #     data[ip] = [props[ip][it] for it in range(5)]
# # data = data.tolist()
# # with open(PATH_CLOUDS+"spl_vals.json","w+") as file:
# #     json.dump(data, file)
# #     file.close()
# # props = props
ddp, tdp, vdp, ddh, tdh, vdh = numpy.zeros(len(dp)), numpy.zeros(len(dp)), numpy.zeros(len(dp)), numpy.zeros(len(dh)), numpy.zeros(len(dh)), numpy.zeros(len(dh))
for ip in range(len(dh)):
# df, Tf, vf = numpy.zeros(len(hf)), numpy.zeros(len(hf)), numpy.zeros(len(hf))
    ddh[ip], tdh[ip], vdh[ip] = dh[ip][4], dh[ip][5], dh[ip][6]
    ddp[ip], tdp[ip], vdp[ip] = dp[ip][4], dp[ip][5], dp[ip][6]

ddh, tdh, vdh = ddh.reshape(hd.shape), tdh.reshape(hd.shape), vdh.reshape(hd.shape)
ddp, tdp, vdp = ddp.reshape(hd.shape), tdp.reshape(hd.shape), vdp.reshape(hd.shape)

bdcp = numpy.linspace(1041., PCRIT, 100)
bch = numpy.array([_hl_p(pi) for pi in bdcp])
dch = numpy.array([_hv_p(pi) for pi in bdcp])
#
# # #######################################
# # # Derivative plots
# f1 = plt.figure("T_derr")
# s1a = f1.add_subplot(121)
# c1a = s1a.contourf(hd * 1e-3, Pd * 1e-6, tdh, 25)
# b1a = plt.colorbar(c1a)
# s1a.plot(bch * 1e-3, bdcp * 1e-6, c='r', label="boiling curve")
# s1a.plot(dch * 1e-3, bdcp * 1e-6, c='b', label="dew curve")
# b1a.ax.set_ylabel("dT/dh", fontsize=16, weight="bold")
# for l in b1a.ax.yaxis.get_ticklabels():
#     l.set_weight("bold")
#     l.set_fontsize(12)
# plt.xticks(weight="bold", fontsize=12)
# plt.yticks(weight="bold", fontsize=12)
# plt.xlabel("Enthalpy (kJ/kg)", weight="bold", fontsize=16)
# plt.ylabel("Pressure (MPa)", weight="bold", fontsize=16)
# plt.title('dT/dh', weight="bold", fontsize=20)
# plt.legend(loc='best')
#
# s1b = f1.add_subplot(122)
# c1b = s1b.contourf(hd * 1e-3, Pd * 1e-6, tdp, 25)
# b1b = plt.colorbar(c1b)
# s1b.plot(bch * 1e-3, bdcp * 1e-6, c='r', label="boiling curve")
# s1b.plot(dch * 1e-3, bdcp * 1e-6, c='b', label="dew curve")
# b1b.ax.set_ylabel("dT/dP", fontsize=16, weight="bold")
# for l in b1b.ax.yaxis.get_ticklabels():
#     l.set_weight("bold")
#     l.set_fontsize(12)
# plt.xticks(weight="bold", fontsize=12)
# plt.yticks(weight="bold", fontsize=12)
# plt.xlabel("Enthalpy (kJ/kg)", weight="bold", fontsize=16)
# plt.ylabel("Pressure (MPa)", weight="bold", fontsize=16)
# plt.title('dT/dP', weight="bold", fontsize=20)
# plt.legend(loc='best')
#
# f2 = plt.figure("d_derr")
# s2a = f2.add_subplot(121)
# c2a = s2a.contourf(hd * 1e-3, Pd * 1e-6, ddh, 25)
# b2a = plt.colorbar(c2a)
# s2a.plot(bch * 1e-3, bdcp * 1e-6, c='r', label="boiling curve")
# s2a.plot(dch * 1e-3, bdcp * 1e-6, c='b', label="dew curve")
# b2a.ax.set_ylabel("dd/dh", fontsize=16, weight="bold")
# for l in b2a.ax.yaxis.get_ticklabels():
#     l.set_weight("bold")
#     l.set_fontsize(12)
# plt.xticks(weight="bold", fontsize=12)
# plt.yticks(weight="bold", fontsize=12)
# plt.xlabel("Enthalpy (kJ/kg)", weight="bold", fontsize=16)
# plt.ylabel("Pressure (MPa)", weight="bold", fontsize=16)
# plt.title('dd/dh', weight="bold", fontsize=20)
# plt.legend(loc='best')
#
# s2b = f2.add_subplot(122)
# c2b = s2b.contourf(hd * 1e-3, Pd * 1e-6, ddp, 25)
# b2b = plt.colorbar(c2b)
# s2b.plot(bch * 1e-3, bdcp * 1e-6, c='r', label="boiling curve")
# s2b.plot(dch * 1e-3, bdcp * 1e-6, c='b', label="dew curve")
# b2b.ax.set_ylabel("dd/dP", fontsize=16, weight="bold")
# for l in b2b.ax.yaxis.get_ticklabels():
#     l.set_weight("bold")
#     l.set_fontsize(12)
# plt.xticks(weight="bold", fontsize=12)
# plt.yticks(weight="bold", fontsize=12)
# plt.xlabel("Enthalpy (kJ/kg)", weight="bold", fontsize=16)
# plt.ylabel("Pressure (MPa)", weight="bold", fontsize=16)
# plt.title('dd/dP', weight="bold", fontsize=20)
# plt.legend(loc='best')
#
f3 = plt.figure("v_derr")
s3a = f3.add_subplot(121)
c3a = s3a.contourf(hd * 1e-3, Pd * 1e-6, vdh, 25)
b3a = plt.colorbar(c3a)
s3a.plot(bch * 1e-3, bdcp * 1e-6, c='r', label="boiling curve")
s3a.plot(dch * 1e-3, bdcp * 1e-6, c='b', label="dew curve")
b3a.ax.set_ylabel("d(1/v)/dh", fontsize=16, weight="bold")
for l in b3a.ax.yaxis.get_ticklabels():
    l.set_weight("bold")
    l.set_fontsize(12)
plt.xticks(weight="bold", fontsize=12)
plt.yticks(weight="bold", fontsize=12)
plt.xlabel("Enthalpy (kJ/kg)", weight="bold", fontsize=16)
plt.ylabel("Pressure (MPa)", weight="bold", fontsize=16)
plt.title('d(1/v)/dh', weight="bold", fontsize=20)
plt.legend(loc='best')

s3b = f3.add_subplot(122)
c3b = s3b.contourf(hd * 1e-3, Pd * 1e-6, vdp, 25)
b3b = plt.colorbar(c3b)
s3b.plot(bch * 1e-3, bdcp * 1e-6, c='r', label="boiling curve")
s3b.plot(dch * 1e-3, bdcp * 1e-6, c='b', label="dew curve")
b3b.ax.set_ylabel("d(1/v)/dP", fontsize=16, weight="bold")
for l in b3b.ax.yaxis.get_ticklabels():
    l.set_weight("bold")
    l.set_fontsize(12)
plt.xticks(weight="bold", fontsize=12)
plt.yticks(weight="bold", fontsize=12)
plt.xlabel("Enthalpy (kJ/kg)", weight="bold", fontsize=16)
plt.ylabel("Pressure (MPa)", weight="bold", fontsize=16)
plt.title('d(1/v)/dP', weight="bold", fontsize=20)
plt.legend(loc='best')

plt.show()
# #######################################


# dd, Td, vd = df.reshape(hd.shape), Tf.reshape(hd.shape), vf.reshape(hd.shape)
#
# n_contours = 25
# plt.figure("density")
# dc = plt.contourf(hd,Pd,dd,n_contours)
# plt.colorbar(dc)
# plt.figure("Temperature")
# Tc = plt.contourf(hd,Pd,Td,n_contours)
# plt.colorbar(Tc)
# plt.figure("viscosity")
# vc = plt.contourf(hd,Pd,vd,n_contours)
# plt.colorbar(vc)
# plt.show()

# pressures = [30e6, 5e6] #, 10e6, 1e5
# enthalpy = numpy.linspace(HMIN,HMAX,1000)
# # pressures = [30e6,5e6] #, 10e6, 1e5
# # enthalpy = numpy.linspace(PMIN,PMAX,10000)
# de = 1e-5
# denthalpy = enthalpy + de
# ft = plt.figure("res_dtdh")
# fitt = ft.add_subplot(111)
# plt.title("Residual on dT/dh", fontsize=20, weight="bold")
# plt.xlabel("Enthalpy (kJ/kg)", fontsize=16, weight="bold")
# plt.ylabel("Residual", fontsize=16, weight="bold")
# plt.xticks(weight="bold", fontsize=12)
# plt.yticks(weight="bold", fontsize=12)
# fd = plt.figure("res_dddh")
# fidd = fd.add_subplot(111)
# plt.title("Residual on dd/dh", fontsize=20, weight="bold")
# plt.xlabel("Enthalpy (kJ/kg)", fontsize=16, weight="bold")
# plt.ylabel("Residual", fontsize=16, weight="bold")
# plt.xticks(weight="bold", fontsize=12)
# plt.yticks(weight="bold", fontsize=12)
# fv = plt.figure("res_dvdh")
# fivv = fv.add_subplot(111)
# plt.title("Residual on dv/dh", fontsize=20, weight="bold")
# plt.xlabel("Enthalpy (kJ/kg)", fontsize=16, weight="bold")
# plt.ylabel("Residual", fontsize=16, weight="bold")
# plt.xticks(weight="bold", fontsize=12)
# plt.yticks(weight="bold", fontsize=12)
# for pr in pressures:
#     # props = properties(pr,enthalpy)
#     # delta = properties(pr,denthalpy)
#     # dh_props = properties(pr, enthalpy, dy=1)
#     props = properties(enthalpy,pr)
#     delta = properties(denthalpy, pr)
#     dh_props = properties(enthalpy,pr, dx=1)
#     dfdh, Tfdh, vfdh = numpy.zeros(len(enthalpy)), numpy.zeros(len(enthalpy)), numpy.zeros(len(enthalpy))
#     df, Tf, vf = numpy.zeros(len(enthalpy)), numpy.zeros(len(enthalpy)), numpy.zeros(len(enthalpy))
#     fdd, fdT, fdv = numpy.zeros(len(enthalpy)), numpy.zeros(len(enthalpy)), numpy.zeros(len(enthalpy))
#     resd, resT, resv = numpy.zeros(len(enthalpy)), numpy.zeros(len(enthalpy)), numpy.zeros(len(enthalpy))
#     for ip in range(len(props)):
#         df[ip], Tf[ip], vf[ip] = (delta[ip][2] - props[ip][2]) / de,(delta[ip][3] - props[ip][3]) / de, (delta[ip][4] - props[ip][4]) / de
#         dfdh[ip], Tfdh[ip], vfdh[ip] = dh_props[ip][4], dh_props[ip][5], dh_props[ip][6]
#         resd[ip], resT[ip], resv[ip] = df[ip] - dfdh[ip], Tf[ip] - Tfdh[ip], vf[ip] - vfdh[ip]
#
#     fitt.plot(enthalpy,resT, label="P= " + str(pr*1e-6) + " MPa")
#     fidd.plot(enthalpy,resT, label="P= " + str(pr*1e-6) + " MPa")
#     fivv.plot(enthalpy,resT, label="P= " + str(pr*1e-6) + " MPa")
# fivv.legend()
# fitt.legend()
# fidd.legend()
# plt.show()
